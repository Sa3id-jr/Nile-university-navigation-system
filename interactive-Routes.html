<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nile University - Campus Navigator</title>
  <meta name="theme-color" content="#6366f1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      background: #0a0e1a;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .sidebar {
      width: 380px;
      background: linear-gradient(180deg, #1a1f35 0%, #0f1420 100%);
      color: #e8edf5;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      box-shadow: 4px 0 24px rgba(0, 0, 0, 0.5);
      border-right: 1px solid rgba(99, 102, 241, 0.2);
    }

    .sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.3);
      border-radius: 3px;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      gap: 14px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .logo {
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 800;
      color: white;
      box-shadow: 0 8px 16px rgba(99, 102, 241, 0.3);
    }

    .sidebar-header h1 {
      font-size: 20px;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .sidebar-header p {
      font-size: 12px;
      color: #94a3b8;
      margin-top: 2px;
    }

    .status-bar {
      display: flex;
      gap: 8px;
      padding: 12px;
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 10px;
      align-items: center;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background: #10b981;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .status-text {
      font-size: 13px;
      color: #10b981;
      font-weight: 600;
    }

    .search-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .section-title {
      font-size: 13px;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .input-wrapper {
      position: relative;
    }

    .input-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 18px;
      pointer-events: none;
      z-index: 1;
    }

    .search-input {
      width: 100%;
      padding: 14px 16px 14px 48px;
      background: rgba(30, 41, 59, 0.8);
      border: 2px solid rgba(99, 102, 241, 0.2);
      border-radius: 12px;
      color: #e2e8f0;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .search-input::placeholder {
      color: #64748b;
    }

    .search-input:focus {
      outline: none;
      border-color: #6366f1;
      background: rgba(30, 41, 59, 1);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
    }

    .route-btn {
      padding: 16px 24px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border: none;
      border-radius: 12px;
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .route-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }

    .route-btn:active {
      transform: translateY(0);
    }

    .route-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .control-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .control-btn {
      padding: 12px 16px;
      background: rgba(51, 65, 85, 0.8);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 10px;
      color: #e2e8f0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s ease;
    }

    .control-btn:hover {
      background: rgba(71, 85, 105, 0.8);
      border-color: #6366f1;
    }

    .directions-panel {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 12px;
      padding: 16px;
      display: none;
      max-height: 300px;
      overflow-y: auto;
    }

    .directions-panel.active {
      display: block;
    }

    .directions-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .directions-title {
      font-size: 14px;
      font-weight: 600;
      color: #10b981;
    }

    .directions-distance {
      font-size: 12px;
      color: #64748b;
    }

    .direction-step {
      display: flex;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .step-number {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      flex-shrink: 0;
    }

    .step-content {
      flex: 1;
    }

    .step-instruction {
      font-size: 13px;
      color: #e2e8f0;
      margin-bottom: 4px;
    }

    .step-detail {
      font-size: 11px;
      color: #64748b;
    }

    .autocomplete-box {
      position: absolute;
      width: 100%;
      background: #1e293b;
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 10px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      margin-top: 4px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .autocomplete-item {
      padding: 12px 16px;
      cursor: pointer;
      color: #e2e8f0;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: all 0.2s ease;
    }

    .autocomplete-item:hover {
      background: rgba(99, 102, 241, 0.2);
    }

    .autocomplete-icon {
      font-size: 16px;
    }

    #map {
      flex: 1;
      position: relative;
      background: #0f1420;
    }

    .map-footer {
      margin-top: auto;
      padding-top: 20px;
      font-size: 11px;
      color: #475569;
      text-align: center;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    

    

    @keyframes slideDown {
      from {
        transform: translateY(-100px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Enhanced marker styles */
    .custom-location-marker {
      background: transparent;
      border: none;
    }

    .marker-pin {
      width: 36px;
      height: 36px;
      border-radius: 50% 50% 50% 0;
      transform: rotate(-45deg);
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3px solid white;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      position: relative;
      z-index: 2;
    }

    .marker-icon {
      transform: rotate(45deg);
      font-size: 16px;
    }

    .marker-pulse {
      position: absolute;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      opacity: 0;
      animation: pulse-ring 2s infinite;
      z-index: 1;
    }

    @keyframes pulse-ring {
      0% {
        transform: scale(0.8);
        opacity: 0.8;
      }
      100% {
        transform: scale(2.5);
        opacity: 0;
      }
    }

    .start-marker .marker-pin {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
      width: 44px;
      height: 44px;
      animation: bounce 2s infinite;
    }

    .end-marker .marker-pin {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
      width: 44px;
      height: 44px;
      animation: bounce 2s infinite 0.5s;
    }

    @keyframes bounce {
      0%, 100% {
        transform: rotate(-45deg) translateY(0);
      }
      50% {
        transform: rotate(-45deg) translateY(-10px);
      }
    }

    .animated-route {
      animation: dash 20s linear infinite;
    }

    @keyframes dash {
      to {
        stroke-dashoffset: -1000;
      }
    }

    @keyframes fadeOut {
      to {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    .route-info-compact {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
      border: 1px solid rgba(99, 102, 241, 0.3);
      padding: 14px;
      border-radius: 10px;
      color: #e2e8f0;
      font-size: 13px;
      display: none;
      margin-top: 12px;
    }

    .route-info-compact.active {
      display: block;
    }

    .leaflet-popup-content-wrapper {
      background: rgba(30, 41, 59, 0.98);
      color: #e2e8f0;
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .leaflet-popup-content {
      margin: 16px;
      font-size: 13px;
    }

    .leaflet-popup-tip {
      background: rgba(30, 41, 59, 0.98);
      border: 1px solid rgba(99, 102, 241, 0.3);
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
        max-height: 40vh;
        border-right: none;
        border-bottom: 1px solid rgba(99, 102, 241, 0.2);
      }

      .container {
        flex-direction: column;
      }

      #map {
        height: 60vh;
      }
    }
  </style>
</head>

<body>
  

  <div class="container">
    <div class="sidebar">
      <div class="sidebar-header">
        <div class="logo">NU</div>
        <div>
          <h1>Nile University</h1>
          <p>Advanced Campus Navigator</p>
        </div>
      </div>

      <div class="status-bar">
        <div class="status-dot"></div>
        <div class="status-text">All systems operational</div>
      </div>

      <div class="search-section">
        <div class="section-title">üìç Starting Point</div>
        <div class="input-wrapper">
          <div class="input-icon">üö©</div>
          <input type="text" class="search-input" id="start-input" placeholder="Your current location">
          <div class="autocomplete-box" id="start-box"></div>
        </div>

        <div class="section-title" style="margin-top: 8px;">üéØ Destination</div>
        <div class="input-wrapper">
          <div class="input-icon">üìå</div>
          <input type="text" class="search-input" id="end-input" placeholder="Where do you want to go?">
          <div class="autocomplete-box" id="end-box"></div>
        </div>

        <button class="route-btn" id="route-btn">
          <span>üß≠</span>
          <span>Find Route & Directions</span>
        </button>

        <div class="route-info-compact" id="route-info"></div>

        <div class="directions-panel" id="directions-panel">
          <div class="directions-header">
            <div class="directions-title">Turn-by-Turn Directions</div>
            <div class="directions-distance" id="total-distance"></div>
          </div>
          <div id="directions-steps"></div>
        </div>

        <div class="control-buttons">
          <button class="control-btn" id="reset-btn" title="Reset view">
            <span>‚Üª</span>
            <span>Reset</span>
          </button>
          <button class="control-btn" id="clear-btn" title="Clear route">
            <span>‚úï</span>
            <span>Clear</span>
          </button>
        </div>
      </div>

      <div class="map-footer">
        Enhanced Campus Navigation <br>
        v2.0 with Turn-by-Turn Directions
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // Register inline service worker
    if ('serviceWorker' in navigator) {
      const swCode = `
        const CACHE_NAME = 'nile-campus-nav-v2';
        const urlsToCache = [
          'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
          'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'
        ];

        self.addEventListener('install', event => {
          event.waitUntil(
            caches.open(CACHE_NAME).then(cache => {
              return cache.addAll(urlsToCache);
            })
          );
          self.skipWaiting();
        });

        self.addEventListener('fetch', event => {
          event.respondWith(
            caches.match(event.request).then(response => {
              return response || fetch(event.request).then(fetchResponse => {
                return caches.open(CACHE_NAME).then(cache => {
                  cache.put(event.request, fetchResponse.clone());
                  return fetchResponse;
                });
              });
            }).catch(() => {
              return caches.match(event.request);
            })
          );
        });

        self.addEventListener('activate', event => {
          event.waitUntil(
            caches.keys().then(cacheNames => {
              return Promise.all(
                cacheNames.map(cacheName => {
                  if (cacheName !== CACHE_NAME) {
                    return caches.delete(cacheName);
                  }
                })
              );
            })
          );
          self.clients.claim();
        });
      `;

      const blob = new Blob([swCode], { type: 'application/javascript' });
      const swUrl = URL.createObjectURL(blob);
      
      navigator.serviceWorker.register(swUrl).then(reg => {
        console.log('‚úÖ Service Worker registered:', reg);
      }).catch(err => {
        console.log('‚ùå Service Worker registration failed:', err);
      });
    }

    // Offline support
    const CACHE_NAME = 'campus-map-v1';
    const MAP_DATA_KEY = 'campus_map_data';

    // Check online status
    function updateOnlineStatus() {
      const indicator = document.getElementById('offline-indicator');
      if (!navigator.onLine) {
        indicator.classList.add('show');
      } else {
        indicator.classList.remove('show');
      }
    }

    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);

    // Cache map data
    function cacheMapData() {
      const data = {
        rooms: rooms,
        corridorWaypoints: corridorWaypoints,
        timestamp: Date.now()
      };
      localStorage.setItem(MAP_DATA_KEY, JSON.stringify(data));
    }

    // Initialize map
    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -1, maxZoom: 3 });
    const img_width = 1527;
    const img_height = 1080;
    const bounds = [[0, 0], [img_height, img_width]];
    L.imageOverlay('floor-1.png', bounds).addTo(map);
    map.fitBounds(bounds);

    let currentPathPolyline = null;
    let startMarker = null;
    let endMarker = null;
    let routeMarkers = [];

    // Room nodes (searchable)
    const rooms = {
      "Library": { x: 590, y: 892, category: "study" },
      "Men Bathroom": { x: 468, y: 796, category: "facility" },
      "Room 1": { x: 606, y: 806, category: "classroom" },
      "IT Service Room": { x: 466, y: 722, category: "service" },
      "68B": { x: 604, y: 728, category: "classroom" },
      "Quick": { x: 318, y: 532, category: "food" },
      "Elevators": { x: 464, y: 414, category: "transport" },
      "Women Bathroom": { x: 460, y: 326, category: "facility" },
      "Room 7": { x: 466, y: 258, category: "classroom" },
      "Room 8": { x: 464, y: 181, category: "classroom" },
      "IT Service Room 2": { x: 606, y: 177, category: "service" },
      "Room 50": { x: 612, y: 252, category: "classroom" },
      "Room 51": { x: 608, y: 332, category: "classroom" },
      "Room 52A": { x: 716, y: 450, category: "classroom" },
      "Room 52B": { x: 782, y: 450, category: "classroom" },
      "Room 53": { x: 852, y: 450, category: "classroom" },
      "Stairs": { x: 638, y: 612, category: "transport" },
      "SU": { x: 702, y: 604, category: "office" },
      "HUAC Lab": { x: 774, y: 604, category: "lab" },
      "B43 Civil Lab": { x: 852, y: 604, category: "lab" },
      "Men Bathroom 2": { x: 1140, y: 488, category: "facility" },
      "SU Kitchen": { x: 1070, y: 133, category: "food" },
      "Exit": { x: 1122, y: 898, category: "exit" },
      "Logic Lab": { x: 1142, y: 796, category: "lab" },
      "NUMC Music Club": { x: 990, y: 804, category: "club" },
      "Physics Lab": { x: 993, y: 721, category: "lab" },
      "Women Bathroom 2": { x: 1146, y: 542, category: "facility" },
      "Elevators 2": { x: 1139, y: 601, category: "transport" }
    };

    // Corridor waypoints
    const corridorWaypoints = {};

    // Generate waypoints for corridors
    for (let y = 170; y <= 820; y += 50) {
      corridorWaypoints[`W_L${y}`] = { x: 540, y: y };
    }

    for (let x = 280; x <= 1080; x += 50) {
      corridorWaypoints[`W_H${x}`] = { x: x, y: 525 };
    }

    for (let y = 123; y <= 835; y += 50) {
      corridorWaypoints[`W_R${y}`] = { x: 1080, y: y };
    }

    // Cache data
    cacheMapData();

    // Build graph
    const allNodes = { ...rooms, ...corridorWaypoints };
    const graph = {};
    for (let node in allNodes) {
      graph[node] = [];
    }

    function addEdge(from, to) {
      const fromNode = allNodes[from];
      const toNode = allNodes[to];
      const dx = toNode.x - fromNode.x;
      const dy = toNode.y - fromNode.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      graph[from].push({
        node: to,
        distance: distance,
        points: [[fromNode.x, fromNode.y], [toNode.x, toNode.y]]
      });

      graph[to].push({
        node: from,
        distance: distance,
        points: [[toNode.x, toNode.y], [fromNode.x, fromNode.y]]
      });
    }

    // Connect corridor waypoints
    const leftWaypoints = Object.keys(corridorWaypoints).filter(k => k.startsWith('W_L')).sort((a, b) => {
      return parseInt(a.substring(3)) - parseInt(b.substring(3));
    });
    for (let i = 0; i < leftWaypoints.length - 1; i++) {
      addEdge(leftWaypoints[i], leftWaypoints[i + 1]);
    }

    const horizWaypoints = Object.keys(corridorWaypoints).filter(k => k.startsWith('W_H')).sort((a, b) => {
      return parseInt(a.substring(3)) - parseInt(b.substring(3));
    });
    for (let i = 0; i < horizWaypoints.length - 1; i++) {
      addEdge(horizWaypoints[i], horizWaypoints[i + 1]);
    }

    const rightWaypoints = Object.keys(corridorWaypoints).filter(k => k.startsWith('W_R')).sort((a, b) => {
      return parseInt(a.substring(3)) - parseInt(b.substring(3));
    });
    for (let i = 0; i < rightWaypoints.length - 1; i++) {
      addEdge(rightWaypoints[i], rightWaypoints[i + 1]);
    }

    // Connect intersections
    addEdge('W_L520', 'W_H530');
    addEdge('W_H1080', 'W_R523');

    // Connect rooms to corridors
    Object.keys(rooms).forEach(roomName => {
      const room = rooms[roomName];
      let minDist = Infinity;
      let nearestWaypoint = null;

      Object.keys(corridorWaypoints).forEach(waypointName => {
        const waypoint = corridorWaypoints[waypointName];
        const dx = waypoint.x - room.x;
        const dy = waypoint.y - room.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < minDist) {
          minDist = dist;
          nearestWaypoint = waypointName;
        }
      });

      if (nearestWaypoint) {
        addEdge(roomName, nearestWaypoint);
      }
    });

    // Dijkstra's algorithm
    function dijkstra(start, end) {
      const distances = {};
      const previous = {};
      const pq = [];

      for (let node in graph) {
        distances[node] = Infinity;
        previous[node] = null;
      }

      distances[start] = 0;
      pq.push({ node: start, distance: 0 });

      while (pq.length > 0) {
        pq.sort((a, b) => a.distance - b.distance);
        const { node: current } = pq.shift();

        if (current === end) break;

        for (let neighbor of graph[current]) {
          const alt = distances[current] + neighbor.distance;
          if (alt < distances[neighbor.node]) {
            distances[neighbor.node] = alt;
            previous[neighbor.node] = { node: current, points: neighbor.points };
            pq.push({ node: neighbor.node, distance: alt });
          }
        }
      }

      const path = [];
      let current = end;
      while (previous[current]) {
        path.unshift({ node: current, points: previous[current].points });
        current = previous[current].node;
      }
      if (path.length > 0) path.unshift({ node: start, points: [] });

      return { path, distance: distances[end] };
    }

    function getFullPolylinePoints(pathNodes) {
      const fullPath = [];
      for (let i = 0; i < pathNodes.length - 1; i++) {
        const segment = pathNodes[i + 1].points;
        fullPath.push(...segment);
      }
      return fullPath;
    }

    // Generate turn-by-turn directions
    function generateDirections(pathNodes) {
      const directions = [];
      let currentDirection = null;
      let stepDistance = 0;

      for (let i = 0; i < pathNodes.length - 1; i++) {
        const current = allNodes[pathNodes[i].node];
        const next = allNodes[pathNodes[i + 1].node];
        
        const dx = next.x - current.x;
        const dy = next.y - current.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        let direction = null;
        if (Math.abs(dx) > Math.abs(dy)) {
          direction = dx > 0 ? 'right' : 'left';
        } else {
          direction = dy > 0 ? 'down' : 'up';
        }

        if (direction !== currentDirection && currentDirection !== null) {
          directions.push({
            instruction: getTurnInstruction(currentDirection, direction),
            distance: (stepDistance * 0.3).toFixed(0),
            type: 'turn'
          });
          stepDistance = distance;
        } else {
          stepDistance += distance;
        }

        currentDirection = direction;
      }

      if (stepDistance > 0) {
        directions.push({
          instruction: `Continue straight`,
          distance: (stepDistance * 0.3).toFixed(0),
          type: 'continue'
        });
      }

      return directions;
    }

    function getTurnInstruction(from, to) {
      const turns = {
        'right-up': 'Turn left',
        'right-down': 'Turn right',
        'left-up': 'Turn right',
        'left-down': 'Turn left',
        'up-right': 'Turn right',
        'up-left': 'Turn left',
        'down-right': 'Turn left',
        'down-left': 'Turn right'
      };
      return turns[`${from}-${to}`] || 'Continue';
    }

    function displayDirections(directions, startRoom, endRoom) {
      const panel = document.getElementById('directions-panel');
      const stepsContainer = document.getElementById('directions-steps');
      stepsContainer.innerHTML = '';

      // Start step
      const startStep = document.createElement('div');
      startStep.className = 'direction-step';
      startStep.innerHTML = `
        <div class="step-number">üö©</div>
        <div class="step-content">
          <div class="step-instruction">Start at ${startRoom}</div>
          <div class="step-detail">Begin your journey</div>
        </div>
      `;
      stepsContainer.appendChild(startStep);

      // Turn steps
      directions.forEach((dir, index) => {
        const step = document.createElement('div');
        step.className = 'direction-step';
        step.innerHTML = `
          <div class="step-number">${index + 1}</div>
          <div class="step-content">
            <div class="step-instruction">${dir.instruction}</div>
            <div class="step-detail">~${dir.distance}m ahead</div>
          </div>
        `;
        stepsContainer.appendChild(step);
      });

      // End step
      const endStep = document.createElement('div');
      endStep.className = 'direction-step';
      endStep.innerHTML = `
        <div class="step-number">üìå</div>
        <div class="step-content">
          <div class="step-instruction">Arrive at ${endRoom}</div>
          <div class="step-detail">You've reached your destination</div>
        </div>
      `;
      stepsContainer.appendChild(endStep);

      panel.classList.add('active');
    }

    const roomNames = Object.keys(rooms);

    const categoryIcons = {
      study: 'üìö',
      facility: 'üöª',
      classroom: 'üéì',
      service: 'üîß',
      food: 'üçΩÔ∏è',
      transport: 'üö™',
      lab: 'üî¨',
      office: 'üè¢',
      club: 'üéµ',
      exit: 'üö™'
    };

    // Enhanced custom marker icons for different categories
    function createCategoryIcon(category, isStart = false, isEnd = false) {
      const colors = {
        study: '#3b82f6',
        facility: '#8b5cf6',
        classroom: '#10b981',
        service: '#f59e0b',
        food: '#ef4444',
        transport: '#6366f1',
        lab: '#06b6d4',
        office: '#ec4899',
        club: '#a855f7',
        exit: '#64748b'
      };

      const color = colors[category] || '#6366f1';
      const icon = categoryIcons[category] || 'üìç';
      
      let className = 'custom-location-marker';
      if (isStart) className = 'start-marker';
      if (isEnd) className = 'end-marker';

      return L.divIcon({
        className: className,
        html: `<div class="marker-pin" style="background: ${color};">
                 <span class="marker-icon">${icon}</span>
               </div>
               <div class="marker-pulse" style="background: ${color};"></div>`,
        iconSize: [40, 40],
        iconAnchor: [20, 40],
        popupAnchor: [0, -40]
      });
    }

    // Autocomplete functionality
    function setupAutocomplete(inputElement, boxElement) {
      inputElement.addEventListener('input', function() {
        const query = this.value.toLowerCase();
        boxElement.innerHTML = '';
        
        if (query.length < 1) {
          boxElement.style.display = 'none';
          return;
        }

        const matches = roomNames.filter(name => 
          name.toLowerCase().includes(query)
        ).slice(0, 8);

        if (matches.length > 0) {
          matches.forEach(name => {
            const room = rooms[name];
            const icon = categoryIcons[room.category] || 'üìç';
            const item = document.createElement('div');
            item.className = 'autocomplete-item';
            item.innerHTML = `
              <span class="autocomplete-icon">${icon}</span>
              <span>${name}</span>
            `;
            item.addEventListener('click', function() {
              inputElement.value = name;
              boxElement.style.display = 'none';
            });
            boxElement.appendChild(item);
          });
          boxElement.style.display = 'block';
        } else {
          boxElement.style.display = 'none';
        }
      });

      // Close autocomplete when clicking outside
      document.addEventListener('click', function(e) {
        if (!inputElement.contains(e.target)) {
          boxElement.style.display = 'none';
        }
      });
    }

    const startInput = document.getElementById('start-input');
    const endInput = document.getElementById('end-input');
    const startBox = document.getElementById('start-box');
    const endBox = document.getElementById('end-box');

    setupAutocomplete(startInput, startBox);
    setupAutocomplete(endInput, endBox);

    // Add room markers to map
    Object.keys(rooms).forEach(roomName => {
      const room = rooms[roomName];
      const marker = L.marker(
        [room.y, room.x],
        { icon: createCategoryIcon(room.category) }
      ).addTo(map);
      
      marker.bindPopup(`
        <div style="padding: 8px;">
          <h3 style="margin: 0 0 8px 0; font-size: 15px; font-weight: 600; color: #fff;">
            ${categoryIcons[room.category]} ${roomName}
          </h3>
          <p style="margin: 0; font-size: 12px; color: #94a3b8; text-transform: capitalize;">
            ${room.category}
          </p>
          <div style="margin-top: 12px; display: flex; gap: 8px;">
            <button onclick="setAsStart('${roomName}')" 
              style="flex: 1; padding: 6px; background: #10b981; border: none; border-radius: 6px; color: white; font-size: 11px; cursor: pointer; font-weight: 600;">
              Start Here
            </button>
            <button onclick="setAsEnd('${roomName}')" 
              style="flex: 1; padding: 6px; background: #6366f1; border: none; border-radius: 6px; color: white; font-size: 11px; cursor: pointer; font-weight: 600;">
              Go Here
            </button>
          </div>
        </div>
      `);
      
      routeMarkers.push(marker);
    });

    // Global functions for popup buttons
    window.setAsStart = function(roomName) {
      startInput.value = roomName;
      map.closePopup();
    };

    window.setAsEnd = function(roomName) {
      endInput.value = roomName;
      map.closePopup();
    };

    // Route calculation and display
    document.getElementById('route-btn').addEventListener('click', function() {
      const startRoom = startInput.value.trim();
      const endRoom = endInput.value.trim();

      if (!rooms[startRoom]) {
        showNotification('‚ùå Start location not found', 'error');
        return;
      }

      if (!rooms[endRoom]) {
        showNotification('‚ùå Destination not found', 'error');
        return;
      }

      if (startRoom === endRoom) {
        showNotification('‚ö†Ô∏è Start and destination cannot be the same', 'error');
        return;
      }

      // Clear previous route
      if (currentPathPolyline) {
        map.removeLayer(currentPathPolyline);
      }
      if (startMarker) map.removeLayer(startMarker);
      if (endMarker) map.removeLayer(endMarker);

      // Calculate route
      const { path, distance } = dijkstra(startRoom, endRoom);

      if (path.length === 0 || distance === Infinity) {
        showNotification('‚ùå No route found', 'error');
        return;
      }

      // Draw route
      const polylinePoints = getFullPolylinePoints(path);
      currentPathPolyline = L.polyline(
        polylinePoints.map(p => [p[1], p[0]]),
        {
          color: '#10b981',
          weight: 6,
          opacity: 0.8,
          lineJoin: 'round',
          lineCap: 'round',
          dashArray: '0, 10',
          className: 'animated-route'
        }
      ).addTo(map);

      // Add animated dash effect
      let offset = 0;
      setInterval(() => {
        offset += 1;
        if (currentPathPolyline) {
          currentPathPolyline.setStyle({ dashOffset: offset + 'px' });
        }
      }, 100);

      // Add start and end markers
      const startPos = rooms[startRoom];
      const endPos = rooms[endRoom];

      startMarker = L.marker(
        [startPos.y, startPos.x],
        { icon: createCategoryIcon(startPos.category, true, false) }
      ).addTo(map);
      
      endMarker = L.marker(
        [endPos.y, endPos.x],
        { icon: createCategoryIcon(endPos.category, false, true) }
      ).addTo(map);

      startMarker.bindPopup(`<strong>üö© Start:</strong> ${startRoom}`);
      endMarker.bindPopup(`<strong>üìå Destination:</strong> ${endRoom}`);

      // Fit bounds to show entire route
      map.fitBounds(currentPathPolyline.getBounds(), { padding: [50, 50] });

      // Display route info
      const distanceMeters = (distance * 0.3).toFixed(0);
      const timeMinutes = Math.ceil(distanceMeters / 80); // Average walking speed 80m/min
      
      const routeInfo = document.getElementById('route-info');
      routeInfo.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="font-weight: 700; color: #10b981; font-size: 15px;">Route Found!</div>
          <div style="font-size: 12px; color: #64748b;">${path.length - 1} segments</div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;">
          <div style="background: rgba(16, 185, 129, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.3);">
            <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Distance</div>
            <div style="font-size: 18px; font-weight: 700; color: #10b981;">~${distanceMeters}m</div>
          </div>
          <div style="background: rgba(99, 102, 241, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3);">
            <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Est. Time</div>
            <div style="font-size: 18px; font-weight: 700; color: #6366f1;">~${timeMinutes} min</div>
          </div>
        </div>
      `;
      routeInfo.classList.add('active');

      // Generate and display directions
      const directions = generateDirections(path);
      displayDirections(directions, startRoom, endRoom);

      document.getElementById('total-distance').textContent = `~${distanceMeters}m ‚Ä¢ ${timeMinutes} min walk`;

      // Show success notification
      showNotification('‚úÖ Route calculated successfully!', 'success');
    });

    // Clear route
    document.getElementById('clear-btn').addEventListener('click', function() {
      if (currentPathPolyline) {
        map.removeLayer(currentPathPolyline);
        currentPathPolyline = null;
      }
      if (startMarker) {
        map.removeLayer(startMarker);
        startMarker = null;
      }
      if (endMarker) {
        map.removeLayer(endMarker);
        endMarker = null;
      }

      startInput.value = '';
      endInput.value = '';
      
      document.getElementById('directions-panel').classList.remove('active');
      document.getElementById('route-info').classList.remove('active');
      
      showNotification('üóëÔ∏è Route cleared', 'info');
    });

    // Reset view
    document.getElementById('reset-btn').addEventListener('click', function() {
      map.fitBounds(bounds);
      showNotification('‚Üª View reset', 'info');
    });

    // Notification system
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      
      const colors = {
        success: '#10b981',
        error: '#ef4444',
        info: '#6366f1'
      };
      
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: ${colors[type]};
        color: white;
        padding: 12px 24px;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        z-index: 10001;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        animation: slideDown 0.3s ease;
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'fadeOut 0.3s ease';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 'k':
            e.preventDefault();
            startInput.focus();
            break;
          case 'Enter':
            e.preventDefault();
            document.getElementById('route-btn').click();
            break;
          case 'Backspace':
            e.preventDefault();
            document.getElementById('clear-btn').click();
            break;
        }
      }
    });

    console.log('üó∫Ô∏è Nile University Campus Navigator v2.0 - Ready!');
  </script>
</body>
</html>
