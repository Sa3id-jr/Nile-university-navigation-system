<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nile University - Multi-Floor Campus Navigator</title>
  <meta name="theme-color" content="#6366f1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      background: #0a0e1a;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .sidebar {
      width: 380px;
      background: linear-gradient(180deg, #1a1f35 0%, #0f1420 100%);
      color: #e8edf5;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      box-shadow: 4px 0 24px rgba(0, 0, 0, 0.5);
      border-right: 1px solid rgba(99, 102, 241, 0.2);
    }

    .sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.3);
      border-radius: 3px;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      gap: 14px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .logo {
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 800;
      color: white;
      box-shadow: 0 8px 16px rgba(99, 102, 241, 0.3);
    }

    .sidebar-header h1 {
      font-size: 20px;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .sidebar-header p {
      font-size: 12px;
      color: #94a3b8;
      margin-top: 2px;
    }

    .status-bar {
      display: flex;
      gap: 8px;
      padding: 12px;
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 10px;
      align-items: center;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background: #10b981;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .status-text {
      font-size: 13px;
      color: #10b981;
      font-weight: 600;
    }

    .floor-selector {
      display: flex;
      gap: 8px;
      padding: 12px;
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 12px;
    }

    .floor-btn {
      flex: 1;
      padding: 12px 16px;
      background: rgba(51, 65, 85, 0.8);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 10px;
      color: #e2e8f0;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .floor-btn:hover {
      background: rgba(71, 85, 105, 0.8);
      border-color: #6366f1;
      transform: translateY(-2px);
    }

    .floor-btn.active {
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-color: #8b5cf6;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .floor-icon {
      font-size: 20px;
    }

    .floor-label {
      font-size: 11px;
      color: #94a3b8;
    }

    .floor-btn.active .floor-label {
      color: white;
    }

    .search-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .section-title {
      font-size: 13px;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .input-wrapper {
      position: relative;
    }

    .input-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 18px;
      pointer-events: none;
      z-index: 1;
    }

    .search-input {
      width: 100%;
      padding: 14px 16px 14px 48px;
      background: rgba(30, 41, 59, 0.8);
      border: 2px solid rgba(99, 102, 241, 0.2);
      border-radius: 12px;
      color: #e2e8f0;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .search-input::placeholder {
      color: #64748b;
    }

    .search-input:focus {
      outline: none;
      border-color: #6366f1;
      background: rgba(30, 41, 59, 1);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
    }

    .route-btn {
      padding: 16px 24px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border: none;
      border-radius: 12px;
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .route-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }

    .route-btn:active {
      transform: translateY(0);
    }

    .route-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .control-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .control-btn {
      padding: 12px 16px;
      background: rgba(51, 65, 85, 0.8);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 10px;
      color: #e2e8f0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s ease;
    }

    .control-btn:hover {
      background: rgba(71, 85, 105, 0.8);
      border-color: #6366f1;
    }

    .directions-panel {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 12px;
      padding: 16px;
      display: none;
      max-height: 300px;
      overflow-y: auto;
    }

    .directions-panel.active {
      display: block;
    }

    .directions-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .directions-title {
      font-size: 14px;
      font-weight: 600;
      color: #10b981;
    }

    .directions-distance {
      font-size: 12px;
      color: #64748b;
    }

    .direction-step {
      display: flex;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .step-number {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      flex-shrink: 0;
    }

    .step-content {
      flex: 1;
    }

    .step-instruction {
      font-size: 13px;
      color: #e2e8f0;
      margin-bottom: 4px;
    }

    .step-detail {
      font-size: 11px;
      color: #64748b;
    }

    .autocomplete-box {
      position: absolute;
      width: 100%;
      background: #1e293b;
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 10px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      margin-top: 4px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .autocomplete-item {
      padding: 12px 16px;
      cursor: pointer;
      color: #e2e8f0;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: all 0.2s ease;
    }

    .autocomplete-item:hover {
      background: rgba(99, 102, 241, 0.2);
    }

    .autocomplete-icon {
      font-size: 16px;
    }

    .room-floor-badge {
      font-size: 10px;
      padding: 2px 6px;
      background: rgba(99, 102, 241, 0.3);
      border-radius: 4px;
      margin-left: auto;
    }

    #map {
      flex: 1;
      position: relative;
      background: #0f1420;
    }

    .map-footer {
      margin-top: auto;
      padding-top: 20px;
      font-size: 11px;
      color: #475569;
      text-align: center;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    .offline-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      background: rgba(239, 68, 68, 0.95);
      color: white;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      display: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 10000;
    }

    .offline-indicator.show {
      display: block;
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        transform: translateY(-100px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .custom-location-marker {
      background: transparent;
      border: none;
    }

    .marker-pin {
      width: 36px;
      height: 36px;
      border-radius: 50% 50% 50% 0;
      transform: rotate(-45deg);
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3px solid white;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      position: relative;
      z-index: 2;
    }

    .marker-icon {
      transform: rotate(45deg);
      font-size: 16px;
    }

    .marker-pulse {
      position: absolute;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      opacity: 0;
      animation: pulse-ring 2s infinite;
      z-index: 1;
    }

    @keyframes pulse-ring {
      0% {
        transform: scale(0.8);
        opacity: 0.8;
      }

      100% {
        transform: scale(2.5);
        opacity: 0;
      }
    }

    .start-marker .marker-pin {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
      width: 44px;
      height: 44px;
      animation: bounce 2s infinite;
    }

    .end-marker .marker-pin {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
      width: 44px;
      height: 44px;
      animation: bounce 2s infinite 0.5s;
    }

    @keyframes bounce {

      0%,
      100% {
        transform: rotate(-45deg) translateY(0);
      }

      50% {
        transform: rotate(-45deg) translateY(-10px);
      }
    }

    .animated-route {
      animation: dash 20s linear infinite;
    }

    @keyframes dash {
      to {
        stroke-dashoffset: -1000;
      }
    }

    @keyframes fadeOut {
      to {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    .route-info-compact {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
      border: 1px solid rgba(99, 102, 241, 0.3);
      padding: 14px;
      border-radius: 10px;
      color: #e2e8f0;
      font-size: 13px;
      display: none;
      margin-top: 12px;
    }

    .route-info-compact.active {
      display: block;
    }

    .leaflet-popup-content-wrapper {
      background: rgba(30, 41, 59, 0.98);
      color: #e2e8f0;
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .leaflet-popup-content {
      margin: 16px;
      font-size: 13px;
    }

    .leaflet-popup-tip {
      background: rgba(30, 41, 59, 0.98);
      border: 1px solid rgba(99, 102, 241, 0.3);
    }

    /* Floor switch button in route */
    .floor-switch-hint {
      background: rgba(139, 92, 246, 0.2);
      border: 1px solid rgba(139, 92, 246, 0.4);
      padding: 10px;
      border-radius: 8px;
      margin-top: 10px;
      font-size: 12px;
      color: #c4b5fd;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .floor-switch-hint:hover {
      background: rgba(139, 92, 246, 0.3);
    }

    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
        max-height: 40vh;
        border-right: none;
        border-bottom: 1px solid rgba(99, 102, 241, 0.2);
      }

      .container {
        flex-direction: column;
      }

      #map {
        height: 60vh;
      }
    }
  </style>
</head>

<body>
  <div class="offline-indicator" id="offline-indicator">
    ‚ö†Ô∏è Offline Mode - Using cached data
  </div>

  <div class="container">
    <div class="sidebar">
      <div class="sidebar-header">
        <div class="logo">NU</div>
        <div>
          <h1>Nile University</h1>
          <p>Multi-Floor Campus Navigator</p>
        </div>
      </div>

      <div class="status-bar">
        <div class="status-dot"></div>
        <div class="status-text">All systems operational</div>
      </div>

      <div class="floor-selector">
        <button class="floor-btn active" data-floor="ground">
          <span class="floor-icon">üè¢</span>
          <span>Ground</span>
          <span class="floor-label">Floor 0</span>
        </button>
        <button class="floor-btn" data-floor="upper">
          <span class="floor-icon">‚¨ÜÔ∏è</span>
          <span>Upper</span>
          <span class="floor-label">Floor 1</span>
        </button>
      </div>

      <div class="search-section">
        <div class="section-title">üìç Starting Point</div>
        <div class="input-wrapper">
          <div class="input-icon">üö©</div>
          <input type="text" class="search-input" id="start-input" placeholder="Your current location">
          <div class="autocomplete-box" id="start-box"></div>
        </div>

        <div class="section-title" style="margin-top: 8px;">üéØ Destination</div>
        <div class="input-wrapper">
          <div class="input-icon">üìå</div>
          <input type="text" class="search-input" id="end-input" placeholder="Where do you want to go?">
          <div class="autocomplete-box" id="end-box"></div>
        </div>

        <button class="route-btn" id="route-btn">
          <span>üß≠</span>
          <span>Find Route & Directions</span>
        </button>

        <div class="route-info-compact" id="route-info"></div>

        <div class="directions-panel" id="directions-panel">
          <div class="directions-header">
            <div class="directions-title">Turn-by-Turn Directions</div>
            <div class="directions-distance" id="total-distance"></div>
          </div>
          <div id="directions-steps"></div>
        </div>

        <div class="control-buttons">
          <button class="control-btn" id="reset-btn" title="Reset view">
            <span>‚Üª</span>
            <span>Reset</span>
          </button>
          <button class="control-btn" id="clear-btn" title="Clear route">
            <span>‚úï</span>
            <span>Clear</span>
          </button>
        </div>
      </div>

      <div class="map-footer">
        Multi-Floor Campus Navigation ‚Ä¢ Offline Ready<br>
        v3.1 with Complete Floor Routing
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // Register inline service worker
    if ('serviceWorker' in navigator) {
      const swCode = `
        const CACHE_NAME = 'nile-campus-nav-v3';
        const urlsToCache = [
          'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
          'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'
        ];

        self.addEventListener('install', event => {
          event.waitUntil(
            caches.open(CACHE_NAME).then(cache => {
              return cache.addAll(urlsToCache);
            })
          );
          self.skipWaiting();
        });

        self.addEventListener('fetch', event => {
          event.respondWith(
            caches.match(event.request).then(response => {
              return response || fetch(event.request).then(fetchResponse => {
                return caches.open(CACHE_NAME).then(cache => {
                  cache.put(event.request, fetchResponse.clone());
                  return fetchResponse;
                });
              });
            }).catch(() => {
              return caches.match(event.request);
            })
          );
        });

        self.addEventListener('activate', event => {
          event.waitUntil(
            caches.keys().then(cacheNames => {
              return Promise.all(
                cacheNames.map(cacheName => {
                  if (cacheName !== CACHE_NAME) {
                    return caches.delete(cacheName);
                  }
                })
              );
            })
          );
          self.clients.claim();
        });
      `;

      const blob = new Blob([swCode], { type: 'application/javascript' });
      const swUrl = URL.createObjectURL(blob);

      navigator.serviceWorker.register(swUrl).then(reg => {
        console.log('‚úÖ Service Worker registered:', reg);
      }).catch(err => {
        console.log('‚ùå Service Worker registration failed:', err);
      });
    }

    const CACHE_NAME = 'campus-map-v1';
    const MAP_DATA_KEY = 'campus_map_data';

    function updateOnlineStatus() {
      const indicator = document.getElementById('offline-indicator');
      if (!navigator.onLine) {
        indicator.classList.add('show');
      } else {
        indicator.classList.remove('show');
      }
    }

    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);

    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -1, maxZoom: 3 });
    const img_width = 1527;
    const img_height = 1080;
    const bounds = [[0, 0], [img_height, img_width]];

    const groundFloorOverlay = L.imageOverlay('floor-1.png', bounds);
    const upperFloorOverlay = L.imageOverlay('floor-1.png', bounds);

    groundFloorOverlay.addTo(map);
    map.fitBounds(bounds);

    let currentFloor = 'ground';
    let currentPathPolylines = {}; // Store polylines for each floor
    let startMarker = null;
    let endMarker = null;
    let routeMarkers = [];
    let allMarkers = {};
    let currentRoutePath = null; // Store the complete route

    const groundFloorRooms = {
      "Library": { x: 590, y: 892, category: "study", floor: "ground" },
      "Men Bathroom": { x: 468, y: 796, category: "facility", floor: "ground" },
      "Room 1": { x: 606, y: 806, category: "classroom", floor: "ground" },
      "IT Service Room": { x: 466, y: 722, category: "service", floor: "ground" },
      "68B": { x: 604, y: 728, category: "classroom", floor: "ground" },
      "Quick": { x: 318, y: 532, category: "food", floor: "ground" },
      "Elevators": { x: 464, y: 414, category: "transport", floor: "ground" },
      "Women Bathroom": { x: 460, y: 326, category: "facility", floor: "ground" },
      "Room 7": { x: 466, y: 258, category: "classroom", floor: "ground" },
      "Room 8": { x: 464, y: 181, category: "classroom", floor: "ground" },
      "IT Service Room 2": { x: 606, y: 177, category: "service", floor: "ground" },
      "Room 50": { x: 612, y: 252, category: "classroom", floor: "ground" },
      "Room 51": { x: 608, y: 332, category: "classroom", floor: "ground" },
      "Room 52A": { x: 716, y: 450, category: "classroom", floor: "ground" },
      "Room 52B": { x: 782, y: 450, category: "classroom", floor: "ground" },
      "Room 53": { x: 852, y: 450, category: "classroom", floor: "ground" },
      "Stairs": { x: 638, y: 612, category: "transport", floor: "ground" },
      "SU": { x: 702, y: 604, category: "office", floor: "ground" },
      "HUAC Lab": { x: 774, y: 604, category: "lab", floor: "ground" },
      "B43 Civil Lab": { x: 852, y: 604, category: "lab", floor: "ground" },
      "Men Bathroom 2": { x: 1140, y: 488, category: "facility", floor: "ground" },
      "SU Kitchen": { x: 1070, y: 133, category: "food", floor: "ground" },
      "Exit": { x: 1122, y: 898, category: "exit", floor: "ground" },
      "Logic Lab": { x: 1142, y: 796, category: "lab", floor: "ground" },
      "NUMC Music Club": { x: 990, y: 804, category: "club", floor: "ground" },
      "Physics Lab": { x: 993, y: 721, category: "lab", floor: "ground" },
      "Women Bathroom 2": { x: 1146, y: 542, category: "facility", floor: "ground" },
      "Elevators 2": { x: 1139, y: 601, category: "transport", floor: "ground" }
    };

    const upperFloorRooms = {
      "FLibrary": { x: 590, y: 892, category: "study", floor: "upper" },
      "FMen Bathroom": { x: 468, y: 796, category: "facility", floor: "upper" },
      "FRoom 1": { x: 606, y: 806, category: "classroom", floor: "upper" },
      "FIT Service Room": { x: 466, y: 722, category: "service", floor: "upper" },
      "F68B": { x: 604, y: 728, category: "classroom", floor: "upper" },
      "FQuick": { x: 318, y: 532, category: "food", floor: "upper" },
      "FElevators": { x: 464, y: 414, category: "transport", floor: "upper" },
      "FWomen Bathroom": { x: 460, y: 326, category: "facility", floor: "upper" },
      "FRoom 7": { x: 466, y: 258, category: "classroom", floor: "upper" },
      "FRoom 8": { x: 464, y: 181, category: "classroom", floor: "upper" },
      "FIT Service Room 2": { x: 606, y: 177, category: "service", floor: "upper" },
      "FRoom 50": { x: 612, y: 252, category: "classroom", floor: "upper" },
      "FRoom 51": { x: 608, y: 332, category: "classroom", floor: "upper" },
      "FRoom 52A": { x: 716, y: 450, category: "classroom", floor: "upper" },
      "FRoom 52B": { x: 782, y: 450, category: "classroom", floor: "upper" },
      "FRoom 53": { x: 852, y: 450, category: "classroom", floor: "upper" },
      "FStairs": { x: 638, y: 612, category: "transport", floor: "upper" },
      "FSU": { x: 702, y: 604, category: "office", floor: "upper" },
      "FHUAC Lab": { x: 774, y: 604, category: "lab", floor: "upper" },
      "FB43 Civil Lab": { x: 852, y: 604, category: "lab", floor: "upper" },
      "FMen Bathroom 2": { x: 1140, y: 488, category: "facility", floor: "upper" },
      "FSU Kitchen": { x: 1070, y: 133, category: "food", floor: "upper" },
      "FExit": { x: 1122, y: 898, category: "exit", floor: "upper" },
      "FLogic Lab": { x: 1142, y: 796, category: "lab", floor: "upper" },
      "FNUMC Music Club": { x: 990, y: 804, category: "club", floor: "upper" },
      "FPhysics Lab": { x: 993, y: 721, category: "lab", floor: "upper" },
      "FWomen Bathroom 2": { x: 1146, y: 542, category: "facility", floor: "upper" },
      "FElevators 2": { x: 1139, y: 601, category: "transport", floor: "upper" }
    };

    const rooms = { ...groundFloorRooms, ...upperFloorRooms };

    const groundCorridorWaypoints = {};
    const upperCorridorWaypoints = {};

    for (let y = 170; y <= 820; y += 50) {
      groundCorridorWaypoints[`W_L${y}`] = { x: 540, y: y, floor: "ground" };
      upperCorridorWaypoints[`FW_L${y}`] = { x: 540, y: y, floor: "upper" };
    }

    for (let x = 280; x <= 1080; x += 50) {
      groundCorridorWaypoints[`W_H${x}`] = { x: x, y: 525, floor: "ground" };
      upperCorridorWaypoints[`FW_H${x}`] = { x: x, y: 525, floor: "upper" };
    }

    for (let y = 123; y <= 835; y += 50) {
      groundCorridorWaypoints[`W_R${y}`] = { x: 1080, y: y, floor: "ground" };
      upperCorridorWaypoints[`FW_R${y}`] = { x: 1080, y: y, floor: "upper" };
    }

    const corridorWaypoints = { ...groundCorridorWaypoints, ...upperCorridorWaypoints };

    function cacheMapData() {
      const data = {
        rooms: rooms,
        corridorWaypoints: corridorWaypoints,
        timestamp: Date.now()
      };
      localStorage.setItem(MAP_DATA_KEY, JSON.stringify(data));
    }
    cacheMapData();

    const allNodes = { ...rooms, ...corridorWaypoints };
    const graph = {};
    for (let node in allNodes) {
      graph[node] = [];
    }

    function addEdge(from, to) {
      const fromNode = allNodes[from];
      const toNode = allNodes[to];

      if (!fromNode || !toNode) return;

      const dx = toNode.x - fromNode.x;
      const dy = toNode.y - fromNode.y;
      let distance = Math.sqrt(dx * dx + dy * dy);

      if (fromNode.floor !== toNode.floor) {
        distance += 300;
      }

      graph[from].push({
        node: to,
        distance: distance,
        points: [[fromNode.x, fromNode.y], [toNode.x, toNode.y]],
        floorChange: fromNode.floor !== toNode.floor
      });

      graph[to].push({
        node: from,
        distance: distance,
        points: [[toNode.x, toNode.y], [fromNode.x, fromNode.y]],
        floorChange: fromNode.floor !== toNode.floor
      });
    }

    const leftWaypoints = Object.keys(groundCorridorWaypoints).filter(k => k.startsWith('W_L')).sort((a, b) => {
      return parseInt(a.substring(3)) - parseInt(b.substring(3));
    });
    for (let i = 0; i < leftWaypoints.length - 1; i++) {
      addEdge(leftWaypoints[i], leftWaypoints[i + 1]);
    }

    const horizWaypoints = Object.keys(groundCorridorWaypoints).filter(k => k.startsWith('W_H')).sort((a, b) => {
      return parseInt(a.substring(3)) - parseInt(b.substring(3));
    });
    for (let i = 0; i < horizWaypoints.length - 1; i++) {
      addEdge(horizWaypoints[i], horizWaypoints[i + 1]);
    }

    const rightWaypoints = Object.keys(groundCorridorWaypoints).filter(k => k.startsWith('W_R')).sort((a, b) => {
      return parseInt(a.substring(3)) - parseInt(b.substring(3));
    });
    for (let i = 0; i < rightWaypoints.length - 1; i++) {
      addEdge(rightWaypoints[i], rightWaypoints[i + 1]);
    }

    const upperLeftWaypoints = Object.keys(upperCorridorWaypoints).filter(k => k.startsWith('FW_L')).sort((a, b) => {
      return parseInt(a.substring(4)) - parseInt(b.substring(4));
    });
    for (let i = 0; i < upperLeftWaypoints.length - 1; i++) {
      addEdge(upperLeftWaypoints[i], upperLeftWaypoints[i + 1]);
    }

    const upperHorizWaypoints = Object.keys(upperCorridorWaypoints).filter(k => k.startsWith('FW_H')).sort((a, b) => {
      return parseInt(a.substring(4)) - parseInt(b.substring(4));
    });
    for (let i = 0; i < upperHorizWaypoints.length - 1; i++) {
      addEdge(upperHorizWaypoints[i], upperHorizWaypoints[i + 1]);
    }

    const upperRightWaypoints = Object.keys(upperCorridorWaypoints).filter(k => k.startsWith('FW_R')).sort((a, b) => {
      return parseInt(a.substring(4)) - parseInt(b.substring(4));
    });
    for (let i = 0; i < upperRightWaypoints.length - 1; i++) {
      addEdge(upperRightWaypoints[i], upperRightWaypoints[i + 1]);
    }

    addEdge('W_L520', 'W_H530');
    addEdge('W_H1080', 'W_R523');
    addEdge('FW_L520', 'FW_H530');
    addEdge('FW_H1080', 'FW_R523');

    addEdge('Elevators', 'FElevators');
    addEdge('Elevators 2', 'FElevators 2');
    addEdge('Stairs', 'FStairs');

    Object.keys(groundFloorRooms).forEach(roomName => {
      const room = groundFloorRooms[roomName];
      let minDist = Infinity;
      let nearestWaypoint = null;

      Object.keys(groundCorridorWaypoints).forEach(waypointName => {
        const waypoint = groundCorridorWaypoints[waypointName];
        const dx = waypoint.x - room.x;
        const dy = waypoint.y - room.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < minDist) {
          minDist = dist;
          nearestWaypoint = waypointName;
        }
      });

      if (nearestWaypoint) {
        addEdge(roomName, nearestWaypoint);
      }
    });

    Object.keys(upperFloorRooms).forEach(roomName => {
      const room = upperFloorRooms[roomName];
      let minDist = Infinity;
      let nearestWaypoint = null;

      Object.keys(upperCorridorWaypoints).forEach(waypointName => {
        const waypoint = upperCorridorWaypoints[waypointName];
        const dx = waypoint.x - room.x;
        const dy = waypoint.y - room.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < minDist) {
          minDist = dist;
          nearestWaypoint = waypointName;
        }
      });

      if (nearestWaypoint) {
        addEdge(roomName, nearestWaypoint);
      }
    });

    function dijkstra(start, end) {
      const distances = {};
      const previous = {};
      const pq = [];

      for (let node in graph) {
        distances[node] = Infinity;
        previous[node] = null;
      }

      distances[start] = 0;
      pq.push({ node: start, distance: 0 });

      while (pq.length > 0) {
        pq.sort((a, b) => a.distance - b.distance);
        const { node: current } = pq.shift();

        if (current === end) break;

        for (let neighbor of graph[current]) {
          const alt = distances[current] + neighbor.distance;
          if (alt < distances[neighbor.node]) {
            distances[neighbor.node] = alt;
            previous[neighbor.node] = {
              node: current,
              points: neighbor.points,
              floorChange: neighbor.floorChange
            };
            pq.push({ node: neighbor.node, distance: alt });
          }
        }
      }

      const path = [];
      let current = end;
      while (previous[current]) {
        path.unshift({
          node: current,
          points: previous[current].points,
          floorChange: previous[current].floorChange
        });
        current = previous[current].node;
      }
      if (path.length > 0) path.unshift({ node: start, points: [], floorChange: false });

      return { path, distance: distances[end] };
    }

    // Get polyline points per floor
    function getPolylinePointsByFloor(pathNodes) {
      const pointsByFloor = {
        ground: [],
        upper: []
      };

      for (let i = 0; i < pathNodes.length - 1; i++) {
        const currentNode = allNodes[pathNodes[i].node];
        const nextNode = allNodes[pathNodes[i + 1].node];

        // Skip floor transitions
        if (pathNodes[i + 1].floorChange) continue;

        const floor = currentNode.floor;
        const segment = pathNodes[i + 1].points;
        pointsByFloor[floor].push(...segment);
      }

      return pointsByFloor;
    }

    function generateDirections(pathNodes) {
      const directions = [];
      let currentDirection = null;
      let stepDistance = 0;

      for (let i = 0; i < pathNodes.length - 1; i++) {
        const current = allNodes[pathNodes[i].node];
        const next = allNodes[pathNodes[i + 1].node];

        const dx = next.x - current.x;
        const dy = next.y - current.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (pathNodes[i + 1].floorChange) {
          if (stepDistance > 0) {
            directions.push({
              instruction: `Continue straight`,
              distance: (stepDistance * 0.3).toFixed(0),
              type: 'continue'
            });
          }

          const transportType = pathNodes[i].node.includes('Elevator') ? 'üõó elevator' : 'üö∂ stairs';
          directions.push({
            instruction: `Take the ${transportType} to ${next.floor === 'upper' ? 'upper floor' : 'ground floor'}`,
            distance: '0',
            type: 'floor-change',
            floor: next.floor
          });
          stepDistance = 0;
          currentDirection = null;
          continue;
        }

        let direction = null;
        if (Math.abs(dx) > Math.abs(dy)) {
          direction = dx > 0 ? 'right' : 'left';
        } else {
          direction = dy > 0 ? 'down' : 'up';
        }

        if (direction !== currentDirection && currentDirection !== null) {
          directions.push({
            instruction: getTurnInstruction(currentDirection, direction),
            distance: (stepDistance * 0.3).toFixed(0),
            type: 'turn'
          });
          stepDistance = distance;
        } else {
          stepDistance += distance;
        }

        currentDirection = direction;
      }

      if (stepDistance > 0) {
        directions.push({
          instruction: `Continue straight`,
          distance: (stepDistance * 0.3).toFixed(0),
          type: 'continue'
        });
      }

      return directions;
    }

    function getTurnInstruction(from, to) {
      const turns = {
        'right-up': 'Turn left',
        'right-down': 'Turn right',
        'left-up': 'Turn right',
        'left-down': 'Turn left',
        'up-right': 'Turn right',
        'up-left': 'Turn left',
        'down-right': 'Turn left',
        'down-left': 'Turn right'
      };
      return turns[`${from}-${to}`] || 'Continue';
    }

    function displayDirections(directions, startRoom, endRoom) {
      const panel = document.getElementById('directions-panel');
      const stepsContainer = document.getElementById('directions-steps');
      stepsContainer.innerHTML = '';

      const startFloor = rooms[startRoom].floor === 'upper' ? 'Upper Floor' : 'Ground Floor';
      const startStep = document.createElement('div');
      startStep.className = 'direction-step';
      startStep.innerHTML = `
        <div class="step-number">üö©</div>
        <div class="step-content">
          <div class="step-instruction">Start at ${startRoom}</div>
          <div class="step-detail">${startFloor} - Begin your journey</div>
        </div>
      `;
      stepsContainer.appendChild(startStep);

      directions.forEach((dir, index) => {
        const step = document.createElement('div');
        step.className = 'direction-step';

        let icon = index + 1;
        let detail = `~${dir.distance}m ahead`;

        if (dir.type === 'floor-change') {
          icon = dir.instruction.includes('elevator') ? 'üõó' : 'üö∂';
          detail = dir.floor === 'upper' ? 'Go to Upper Floor' : 'Go to Ground Floor';

          // Add click handler to switch floors
          step.style.cursor = 'pointer';
          step.onclick = () => {
            document.querySelector(`[data-floor="${dir.floor}"]`).click();
          };
          step.title = 'Click to view this floor';
        }

        step.innerHTML = `
          <div class="step-number">${icon}</div>
          <div class="step-content">
            <div class="step-instruction">${dir.instruction}</div>
            <div class="step-detail">${detail}</div>
          </div>
        `;
        stepsContainer.appendChild(step);
      });

      const endFloor = rooms[endRoom].floor === 'upper' ? 'Upper Floor' : 'Ground Floor';
      const endStep = document.createElement('div');
      endStep.className = 'direction-step';
      endStep.innerHTML = `
        <div class="step-number">üìå</div>
        <div class="step-content">
          <div class="step-instruction">Arrive at ${endRoom}</div>
          <div class="step-detail">${endFloor} - You've reached your destination</div>
        </div>
      `;
      stepsContainer.appendChild(endStep);

      panel.classList.add('active');
    }

    const roomNames = Object.keys(rooms);

    const categoryIcons = {
      study: 'üìö',
      facility: 'üöª',
      classroom: 'üéì',
      service: 'üîß',
      food: 'üçΩÔ∏è',
      transport: 'üö™',
      lab: 'üî¨',
      office: 'üè¢',
      club: 'üéµ',
      exit: 'üö™'
    };

    function createCategoryIcon(category, isStart = false, isEnd = false) {
      const colors = {
        study: '#3b82f6',
        facility: '#8b5cf6',
        classroom: '#10b981',
        service: '#f59e0b',
        food: '#ef4444',
        transport: '#6366f1',
        lab: '#06b6d4',
        office: '#ec4899',
        club: '#a855f7',
        exit: '#64748b'
      };

      const color = colors[category] || '#6366f1';
      const icon = categoryIcons[category] || 'üìç';

      let className = 'custom-location-marker';
      if (isStart) className = 'start-marker';
      if (isEnd) className = 'end-marker';

      return L.divIcon({
        className: className,
        html: `<div class="marker-pin" style="background: ${color};">
                 <span class="marker-icon">${icon}</span>
               </div>
               <div class="marker-pulse" style="background: ${color};"></div>`,
        iconSize: [40, 40],
        iconAnchor: [20, 40],
        popupAnchor: [0, -40]
      });
    }

    function setupAutocomplete(inputElement, boxElement) {
      inputElement.addEventListener('input', function () {
        const query = this.value.toLowerCase();
        boxElement.innerHTML = '';

        if (query.length < 1) {
          boxElement.style.display = 'none';
          return;
        }

        const matches = roomNames.filter(name =>
          name.toLowerCase().includes(query)
        ).slice(0, 8);

        if (matches.length > 0) {
          matches.forEach(name => {
            const room = rooms[name];
            const icon = categoryIcons[room.category] || 'üìç';
            const floorLabel = room.floor === 'upper' ? 'F1' : 'F0';
            const item = document.createElement('div');
            item.className = 'autocomplete-item';
            item.innerHTML = `
              <span class="autocomplete-icon">${icon}</span>
              <span>${name}</span>
              <span class="room-floor-badge">${floorLabel}</span>
            `;
            item.addEventListener('click', function () {
              inputElement.value = name;
              boxElement.style.display = 'none';
            });
            boxElement.appendChild(item);
          });
          boxElement.style.display = 'block';
        } else {
          boxElement.style.display = 'none';
        }
      });

      document.addEventListener('click', function (e) {
        if (!inputElement.contains(e.target)) {
          boxElement.style.display = 'none';
        }
      });
    }

    const startInput = document.getElementById('start-input');
    const endInput = document.getElementById('end-input');
    const startBox = document.getElementById('start-box');
    const endBox = document.getElementById('end-box');

    setupAutocomplete(startInput, startBox);
    setupAutocomplete(endInput, endBox);

    function createMarkersForFloor(floor) {
      const floorRooms = floor === 'ground' ? groundFloorRooms : upperFloorRooms;
      const markers = [];

      Object.keys(floorRooms).forEach(roomName => {
        const room = floorRooms[roomName];
        const marker = L.marker(
          [room.y, room.x],
          { icon: createCategoryIcon(room.category) }
        );

        marker.bindPopup(`
          <div style="padding: 8px;">
            <h3 style="margin: 0 0 8px 0; font-size: 15px; font-weight: 600; color: #fff;">
              ${categoryIcons[room.category]} ${roomName}
            </h3>
            <p style="margin: 0; font-size: 12px; color: #94a3b8; text-transform: capitalize;">
              ${room.category} ‚Ä¢ ${room.floor === 'upper' ? 'Upper Floor' : 'Ground Floor'}
            </p>
            <div style="margin-top: 12px; display: flex; gap: 8px;">
              <button onclick="setAsStart('${roomName}')" 
                style="flex: 1; padding: 6px; background: #10b981; border: none; border-radius: 6px; color: white; font-size: 11px; cursor: pointer; font-weight: 600;">
                Start Here
              </button>
              <button onclick="setAsEnd('${roomName}')" 
                style="flex: 1; padding: 6px; background: #6366f1; border: none; border-radius: 6px; color: white; font-size: 11px; cursor: pointer; font-weight: 600;">
                Go Here
              </button>
            </div>
          </div>
        `);

        markers.push(marker);
      });

      return markers;
    }

    allMarkers['ground'] = createMarkersForFloor('ground');
    allMarkers['upper'] = createMarkersForFloor('upper');

    allMarkers['ground'].forEach(marker => marker.addTo(map));

    // Floor switching with route persistence
    document.querySelectorAll('.floor-btn').forEach(btn => {
      btn.addEventListener('click', function () {
        const targetFloor = this.dataset.floor;

        if (targetFloor === currentFloor) return;

        document.querySelectorAll('.floor-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');

        if (targetFloor === 'ground') {
          map.removeLayer(upperFloorOverlay);
          groundFloorOverlay.addTo(map);
        } else {
          map.removeLayer(groundFloorOverlay);
          upperFloorOverlay.addTo(map);
        }

        allMarkers[currentFloor].forEach(marker => map.removeLayer(marker));
        allMarkers[targetFloor].forEach(marker => marker.addTo(map));

        // Remove old polyline and add new one for this floor
        if (currentPathPolylines[currentFloor]) {
          map.removeLayer(currentPathPolylines[currentFloor]);
        }
        if (currentPathPolylines[targetFloor]) {
          currentPathPolylines[targetFloor].addTo(map);
        }

        // Update markers
        if (startMarker) map.removeLayer(startMarker);
        if (endMarker) map.removeLayer(endMarker);

        if (currentRoutePath) {
          const startRoom = currentRoutePath.start;
          const endRoom = currentRoutePath.end;
          const startPos = rooms[startRoom];
          const endPos = rooms[endRoom];

          if (startPos.floor === targetFloor) {
            startMarker = L.marker(
              [startPos.y, startPos.x],
              { icon: createCategoryIcon(startPos.category, true, false) }
            ).addTo(map);
            startMarker.bindPopup(`<strong>üö© Start:</strong> ${startRoom}`);
          }

          if (endPos.floor === targetFloor) {
            endMarker = L.marker(
              [endPos.y, endPos.x],
              { icon: createCategoryIcon(endPos.category, false, true) }
            ).addTo(map);
            endMarker.bindPopup(`<strong>üìå Destination:</strong> ${endRoom}`);
          }
        }

        currentFloor = targetFloor;

        showNotification(`üè¢ Switched to ${targetFloor === 'ground' ? 'Ground' : 'Upper'} Floor`, 'info');
      });
    });

    window.setAsStart = function (roomName) {
      startInput.value = roomName;
      map.closePopup();
    };

    window.setAsEnd = function (roomName) {
      endInput.value = roomName;
      map.closePopup();
    };

    document.getElementById('route-btn').addEventListener('click', function () {
      const startRoom = startInput.value.trim();
      const endRoom = endInput.value.trim();

      if (!rooms[startRoom]) {
        showNotification('‚ùå Start location not found', 'error');
        return;
      }

      if (!rooms[endRoom]) {
        showNotification('‚ùå Destination not found', 'error');
        return;
      }

      if (startRoom === endRoom) {
        showNotification('‚ö†Ô∏è Start and destination cannot be the same', 'error');
        return;
      }

      // Clear previous route
      Object.values(currentPathPolylines).forEach(polyline => {
        if (polyline) map.removeLayer(polyline);
      });
      currentPathPolylines = {};

      if (startMarker) map.removeLayer(startMarker);
      if (endMarker) map.removeLayer(endMarker);

      const { path, distance } = dijkstra(startRoom, endRoom);

      if (path.length === 0 || distance === Infinity) {
        showNotification('‚ùå No route found', 'error');
        return;
      }

      // Store the route
      currentRoutePath = { start: startRoom, end: endRoom, path: path };

      // Switch to starting floor
      const startFloor = rooms[startRoom].floor;
      if (startFloor !== currentFloor) {
        document.querySelector(`[data-floor="${startFloor}"]`).click();
      }

      // Draw route for BOTH floors
      const pointsByFloor = getPolylinePointsByFloor(path);

      ['ground', 'upper'].forEach(floor => {
        if (pointsByFloor[floor].length > 0) {
          const polyline = L.polyline(
            pointsByFloor[floor].map(p => [p[1], p[0]]),
            {
              color: '#10b981',
              weight: 6,
              opacity: 0.8,
              lineJoin: 'round',
              lineCap: 'round',
              dashArray: '0, 10',
              className: 'animated-route'
            }
          );

          currentPathPolylines[floor] = polyline;

          // Only add to map if it's the current floor
          if (floor === currentFloor) {
            polyline.addTo(map);
          }
        }
      });

      // Animated dash effect
      let offset = 0;
      setInterval(() => {
        offset += 1;
        Object.values(currentPathPolylines).forEach(polyline => {
          if (polyline) {
            polyline.setStyle({ dashOffset: offset + 'px' });
          }
        });
      }, 100);

      // Add markers
      const startPos = rooms[startRoom];
      const endPos = rooms[endRoom];

      if (startPos.floor === currentFloor) {
        startMarker = L.marker(
          [startPos.y, startPos.x],
          { icon: createCategoryIcon(startPos.category, true, false) }
        ).addTo(map);
        startMarker.bindPopup(`<strong>üö© Start:</strong> ${startRoom}`);
      }

      if (endPos.floor === currentFloor) {
        endMarker = L.marker(
          [endPos.y, endPos.x],
          { icon: createCategoryIcon(endPos.category, false, true) }
        ).addTo(map);
        endMarker.bindPopup(`<strong>üìå Destination:</strong> ${endRoom}`);
      }

      if (currentPathPolylines[currentFloor]) {
        map.fitBounds(currentPathPolylines[currentFloor].getBounds(), { padding: [50, 50] });
      }

      const distanceMeters = (distance * 0.3).toFixed(0);
      const timeMinutes = Math.ceil(distanceMeters / 80);

      const routeInfo = document.getElementById('route-info');
      const floorChangeCount = path.filter(p => p.floorChange).length;
      const floorInfo = floorChangeCount > 0 ? ` ‚Ä¢ ${floorChangeCount} floor change${floorChangeCount > 1 ? 's' : ''}` : '';

      routeInfo.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="font-weight: 700; color: #10b981; font-size: 15px;">Route Found!</div>
          <div style="font-size: 12px; color: #64748b;">${path.length - 1} segments${floorInfo}</div>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;">
          <div style="background: rgba(16, 185, 129, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.3);">
            <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Distance</div>
            <div style="font-size: 18px; font-weight: 700; color: #10b981;">~${distanceMeters}m</div>
          </div>
          <div style="background: rgba(99, 102, 241, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3);">
            <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Est. Time</div>
            <div style="font-size: 18px; font-weight: 700; color: #6366f1;">~${timeMinutes} min</div>
          </div>
        </div>
      `;
      routeInfo.classList.add('active');
      const directions = generateDirections(path);
      displayDirections(directions, startRoom, endRoom);

      document.getElementById('total-distance').textContent = `~${distanceMeters}m ‚Ä¢ ${timeMinutes} min walk`;

      // Auto-switch to other floor if route crosses floors
      if (floorChangeCount > 0) {
        const otherFloor = currentFloor === 'ground' ? 'upper' : 'ground';
        showNotification('‚úÖ Route calculated! Switching floors in 2 seconds...', 'success');

        setTimeout(() => {
          document.querySelector(`[data-floor="${otherFloor}"]`).click();
          showNotification(`üîÑ Auto-switched to ${otherFloor === 'ground' ? 'Ground' : 'Upper'} Floor`, 'info');
        }, 2000);
      } else {
        showNotification('‚úÖ Route calculated!', 'success');
      }
    });



    document.getElementById('clear-btn').addEventListener('click', function () {
      Object.values(currentPathPolylines).forEach(polyline => {
        if (polyline) map.removeLayer(polyline);
      });
      currentPathPolylines = {};
      currentRoutePath = null;

      if (startMarker) {
        map.removeLayer(startMarker);
        startMarker = null;
      }
      if (endMarker) {
        map.removeLayer(endMarker);
        endMarker = null;
      }

      startInput.value = '';
      endInput.value = '';

      document.getElementById('directions-panel').classList.remove('active');
      document.getElementById('route-info').classList.remove('active');

      showNotification('üóëÔ∏è Route cleared', 'info');
    });

    document.getElementById('reset-btn').addEventListener('click', function () {
      map.fitBounds(bounds);
      showNotification('‚Üª View reset', 'info');
    });

    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;

      const colors = {
        success: '#10b981',
        error: '#ef4444',
        info: '#6366f1'
      };

      notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: ${colors[type]};
        color: white;
        padding: 12px 24px;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        z-index: 10001;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        animation: slideDown 0.3s ease;
      `;

      document.body.appendChild(notification);

      setTimeout(() => {
        notification.style.animation = 'fadeOut 0.3s ease';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 'k':
            e.preventDefault();
            startInput.focus();
            break;
          case 'Enter':
            e.preventDefault();
            document.getElementById('route-btn').click();
            break;
          case 'Backspace':
            e.preventDefault();
            document.getElementById('clear-btn').click();
            break;
        }
      }
    });

    console.log('üó∫Ô∏è Nile University Multi-Floor Campus Navigator v3.1 - Ready!');
  </script>
</body>

</html>
