<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nile University - Multi-Floor Campus Navigator</title>
  <meta name="theme-color" content="#6366f1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      background: #0a0e1a;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    .sidebar {
      width: 380px;
      background: linear-gradient(180deg, #1a1f35 0%, #0f1420 100%);
      color: #e8edf5;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      box-shadow: 4px 0 24px rgba(0, 0, 0, 0.5);
      border-right: 1px solid rgba(99, 102, 241, 0.2);
    }

    .sidebar::-webkit-scrollbar {
      width: 6px;
    }

    .sidebar::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: rgba(99, 102, 241, 0.3);
      border-radius: 3px;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      gap: 14px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .logo {
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 800;
      color: white;
      box-shadow: 0 8px 16px rgba(99, 102, 241, 0.3);
    }

    .sidebar-header h1 {
      font-size: 20px;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .sidebar-header p {
      font-size: 12px;
      color: #94a3b8;
      margin-top: 2px;
    }

    .status-bar {
      display: flex;
      gap: 8px;
      padding: 12px;
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 10px;
      align-items: center;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      background: #10b981;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .status-text {
      font-size: 13px;
      color: #10b981;
      font-weight: 600;
    }

    .floor-selector {
      display: flex;
      gap: 8px;
      padding: 12px;
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 12px;
    }

    .floor-btn {
      flex: 1;
      padding: 12px 16px;
      background: rgba(51, 65, 85, 0.8);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 10px;
      color: #e2e8f0;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .floor-btn:hover {
      background: rgba(71, 85, 105, 0.8);
      border-color: #6366f1;
      transform: translateY(-2px);
    }

    .floor-btn.active {
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-color: #8b5cf6;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .floor-icon {
      font-size: 20px;
    }

    .floor-label {
      font-size: 11px;
      color: #94a3b8;
    }

    .floor-btn.active .floor-label {
      color: white;
    }

    .search-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .section-title {
      font-size: 13px;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .input-wrapper {
      position: relative;
    }

    .input-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 18px;
      pointer-events: none;
      z-index: 1;
    }

    .search-input {
      width: 100%;
      padding: 14px 16px 14px 48px;
      background: rgba(30, 41, 59, 0.8);
      border: 2px solid rgba(99, 102, 241, 0.2);
      border-radius: 12px;
      color: #e2e8f0;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .search-input::placeholder {
      color: #64748b;
    }

    .search-input:focus {
      outline: none;
      border-color: #6366f1;
      background: rgba(30, 41, 59, 1);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
    }

    .route-btn {
      padding: 16px 24px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border: none;
      border-radius: 12px;
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .route-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
    }

    .route-btn:active {
      transform: translateY(0);
    }

    .route-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .control-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .control-btn {
      padding: 12px 16px;
      background: rgba(51, 65, 85, 0.8);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 10px;
      color: #e2e8f0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s ease;
    }

    .control-btn:hover {
      background: rgba(71, 85, 105, 0.8);
      border-color: #6366f1;
    }

    .directions-panel {
      background: rgba(30, 41, 59, 0.6);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 12px;
      padding: 16px;
      display: none;
      max-height: 300px;
      overflow-y: auto;
    }

    .directions-panel.active {
      display: block;
    }

    .directions-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .directions-title {
      font-size: 14px;
      font-weight: 600;
      color: #10b981;
    }

    .directions-distance {
      font-size: 12px;
      color: #64748b;
    }

    .direction-step {
      display: flex;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .step-number {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      flex-shrink: 0;
    }

    .step-content {
      flex: 1;
    }

    .step-instruction {
      font-size: 13px;
      color: #e2e8f0;
      margin-bottom: 4px;
    }

    .step-detail {
      font-size: 11px;
      color: #64748b;
    }

    .autocomplete-box {
      position: absolute;
      width: 100%;
      background: #1e293b;
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 10px;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 9999;
      margin-top: 4px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .autocomplete-item {
      padding: 12px 16px;
      cursor: pointer;
      color: #e2e8f0;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: all 0.2s ease;
    }

    .autocomplete-item:hover {
      background: rgba(99, 102, 241, 0.2);
    }

    .autocomplete-icon {
      font-size: 16px;
    }

    .room-floor-badge {
      font-size: 10px;
      padding: 2px 6px;
      background: rgba(99, 102, 241, 0.3);
      border-radius: 4px;
      margin-left: auto;
    }

    #map {
      flex: 1;
      position: relative;
      background: #0f1420;
    }

    .map-footer {
      margin-top: auto;
      padding-top: 20px;
      font-size: 11px;
      color: #475569;
      text-align: center;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    .offline-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 12px 20px;
      background: rgba(239, 68, 68, 0.95);
      color: white;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      display: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 10000;
    }

    .offline-indicator.show {
      display: block;
      animation: slideDown 0.3s ease;
    }

    @keyframes slideDown {
      from {
        transform: translateY(-100px);
        opacity: 0;
      }

      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .custom-location-marker {
      background: transparent;
      border: none;
    }

    .marker-pin {
      width: 36px;
      height: 36px;
      border-radius: 50% 50% 50% 0;
      transform: rotate(-45deg);
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3px solid white;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      position: relative;
      z-index: 2;
    }

    .marker-icon {
      transform: rotate(45deg);
      font-size: 16px;
    }

    .marker-pulse {
      position: absolute;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      opacity: 0;
      animation: pulse-ring 2s infinite;
      z-index: 1;
    }

    @keyframes pulse-ring {
      0% {
        transform: scale(0.8);
        opacity: 0.8;
      }

      100% {
        transform: scale(2.5);
        opacity: 0;
      }
    }

    .start-marker .marker-pin {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
      width: 44px;
      height: 44px;
      animation: bounce 2s infinite;
    }

    .end-marker .marker-pin {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
      width: 44px;
      height: 44px;
      animation: bounce 2s infinite 0.5s;
    }

    @keyframes bounce {

      0%,
      100% {
        transform: rotate(-45deg) translateY(0);
      }

      50% {
        transform: rotate(-45deg) translateY(-10px);
      }
    }

    .animated-route {
      animation: dash 20s linear infinite;
    }

    @keyframes dash {
      to {
        stroke-dashoffset: -1000;
      }
    }

    @keyframes fadeOut {
      to {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    .route-info-compact {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
      border: 1px solid rgba(99, 102, 241, 0.3);
      padding: 14px;
      border-radius: 10px;
      color: #e2e8f0;
      font-size: 13px;
      display: none;
      margin-top: 12px;
    }

    .route-info-compact.active {
      display: block;
    }

    .leaflet-popup-content-wrapper {
      background: rgba(30, 41, 59, 0.98);
      color: #e2e8f0;
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .leaflet-popup-content {
      margin: 16px;
      font-size: 13px;
    }

    .leaflet-popup-tip {
      background: rgba(30, 41, 59, 0.98);
      border: 1px solid rgba(99, 102, 241, 0.3);
    }

    /* Floor switch button in route */
    .floor-switch-hint {
      background: rgba(139, 92, 246, 0.2);
      border: 1px solid rgba(139, 92, 246, 0.4);
      padding: 10px;
      border-radius: 8px;
      margin-top: 10px;
      font-size: 12px;
      color: #c4b5fd;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .floor-switch-hint:hover {
      background: rgba(139, 92, 246, 0.3);
    }

    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
        max-height: 40vh;
        border-right: none;
        border-bottom: 1px solid rgba(99, 102, 241, 0.2);
      }

      .container {
        flex-direction: column;
      }

      #map {
        height: 60vh;
      }
    }
  
    /* ============ DARK/LIGHT MODE VARIABLES ============ */
    :root {
      --bg-primary: #0a0e1a;
      --bg-secondary: #1a1f35;
      --bg-tertiary: #0f1420;
      --text-primary: #e8edf5;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --border-color: rgba(99, 102, 241, 0.2);
      --card-bg: rgba(30, 41, 59, 0.6);
      --card-bg-solid: rgba(30, 41, 59, 0.8);
      --shadow: rgba(0, 0, 0, 0.5);
      --scrollbar-bg: rgba(255, 255, 255, 0.05);
      --scrollbar-thumb: rgba(99, 102, 241, 0.3);
    }

    body.light-mode {
      --bg-primary: #f8fafc;
      --bg-secondary: #ffffff;
      --bg-tertiary: #f1f5f9;
      --text-primary: #1e293b;
      --text-secondary: #475569;
      --text-muted: #64748b;
      --border-color: rgba(99, 102, 241, 0.3);
      --card-bg: rgba(255, 255, 255, 0.8);
      --card-bg-solid: rgba(255, 255, 255, 0.95);
      --shadow: rgba(0, 0, 0, 0.1);
      --scrollbar-bg: rgba(0, 0, 0, 0.05);
      --scrollbar-thumb: rgba(99, 102, 241, 0.4);
    }

    /* Theme Toggle Button */
    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10001;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border: none;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .theme-toggle:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(99, 102, 241, 0.6);
    }

    .theme-toggle svg {
      width: 24px;
      height: 24px;
      fill: white;
      transition: transform 0.3s ease;
    }

    .theme-toggle:active svg {
      transform: rotate(180deg);
    }

    /* Update body background */
    body {
      background: var(--bg-primary);
      transition: background 0.3s ease;
    }

    /* Update sidebar */
    .sidebar {
      background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
      color: var(--text-primary);
      box-shadow: 4px 0 24px var(--shadow);
      border-right: 1px solid var(--border-color);
      transition: all 0.3s ease;
    }

    .sidebar::-webkit-scrollbar-track {
      background: var(--scrollbar-bg);
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
    }

    .sidebar-header {
      border-bottom: 1px solid var(--border-color);
    }

    .sidebar-header h1 {
      color: var(--text-primary);
    }

    .sidebar-header p {
      color: var(--text-secondary);
    }

    /* Floor selector */
    .floor-selector {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
    }

    .floor-btn {
      background: var(--card-bg-solid);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
    }

    .floor-btn:hover {
      background: rgba(99, 102, 241, 0.15);
    }

    .floor-label {
      color: var(--text-secondary);
    }

    /* Search inputs */
    .search-input {
      background: var(--card-bg-solid);
      border: 2px solid var(--border-color);
      color: var(--text-primary);
    }

    .search-input::placeholder {
      color: var(--text-muted);
    }

    .input-icon {
      color: var(--text-muted);
    }

    /* Control buttons */
    .control-btn {
      background: var(--card-bg-solid);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
    }

    .control-btn:hover {
      background: rgba(99, 102, 241, 0.15);
    }

    /* Directions panel */
    .directions-panel {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
    }

    .directions-header {
      border-bottom: 1px solid var(--border-color);
    }

    .direction-step {
      border-bottom: 1px solid var(--border-color);
    }

    .step-instruction {
      color: var(--text-primary);
    }

    .step-detail {
      color: var(--text-muted);
    }

    /* Autocomplete */
    .autocomplete-box {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      box-shadow: 0 8px 24px var(--shadow);
    }

    .autocomplete-item {
      color: var(--text-primary);
    }

    .autocomplete-item:hover {
      background: rgba(99, 102, 241, 0.2);
    }

    /* Map */
    #map {
      background: var(--bg-primary);
    }

    /* Map footer */
    .map-footer {
      color: var(--text-muted);
      border-top: 1px solid var(--border-color);
    }

    /* Section titles */
    .section-title {
      color: var(--text-muted);
    }

    /* Route info compact */
    .route-info-compact {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
    }

    /* Leaflet popups */
    .leaflet-popup-content-wrapper {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      box-shadow: 0 8px 24px var(--shadow);
    }

    .leaflet-popup-tip {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
    }

    /* Floor switch hint */
    .floor-switch-hint {
      background: rgba(139, 92, 246, 0.2);
      border: 1px solid rgba(139, 92, 246, 0.4);
      color: var(--text-primary);
    }

    body.light-mode .floor-switch-hint {
      background: rgba(139, 92, 246, 0.15);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .theme-toggle {
        top: 12px;
        right: 12px;
        width: 44px;
        height: 44px;
      }

      .theme-toggle svg {
        width: 20px;
        height: 20px;
      }
    }
</style>
</head>

<body>
  <!-- Theme Toggle Button -->
  <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme" title="Toggle dark/light mode">
    <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="white" stroke-width="2" fill="none">
      <circle cx="12" cy="12" r="5"/>
      <line x1="12" y1="1" x2="12" y2="3"/>
      <line x1="12" y1="21" x2="12" y2="23"/>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
      <line x1="1" y1="12" x2="3" y2="12"/>
      <line x1="21" y1="12" x2="23" y2="12"/>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
    </svg>
    <svg class="moon-icon" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
    </svg>
  </button>


  <div class="offline-indicator" id="offline-indicator">
    ‚ö†Ô∏è Offline Mode - Using cached data
  </div>

  <div class="container">
    <div class="sidebar">
      <div class="sidebar-header">
        <div class="logo">NU</div>
        <div>
          <h1>Nile University</h1>
          <p>Multi-Floor Campus Navigator</p>
        </div>
      </div>

      <div class="status-bar">
        <div class="status-dot"></div>
        <div class="status-text">All systems operational</div>
      </div>

      <div class="floor-selector">
        <button class="floor-btn active" data-floor="ground">
          <span class="floor-icon">üè¢</span>
          <span>Ground</span>
          <span class="floor-label">Floor 0</span>
        </button>
        <button class="floor-btn" data-floor="upper">
          <span class="floor-icon">‚¨ÜÔ∏è</span>
          <span>Upper</span>
          <span class="floor-label">Floor 1</span>
        </button>
      </div>

      <div class="search-section">
        <div class="section-title">üìç Starting Point</div>
        <div class="input-wrapper">
          <div class="input-icon">üö©</div>
          <input type="text" class="search-input" id="start-input" placeholder="Your current location">
          <div class="autocomplete-box" id="start-box"></div>
        </div>

        <div class="section-title" style="margin-top: 8px;">üéØ Destination</div>
        <div class="input-wrapper">
          <div class="input-icon">üìå</div>
          <input type="text" class="search-input" id="end-input" placeholder="Where do you want to go?">
          <div class="autocomplete-box" id="end-box"></div>
        </div>

        <button class="route-btn" id="route-btn">
          <span>üß≠</span>
          <span>Find Route & Directions</span>
        </button>

        <div class="route-info-compact" id="route-info"></div>

        <div class="directions-panel" id="directions-panel">
          <div class="directions-header">
            <div class="directions-title">Turn-by-Turn Directions</div>
            <div class="directions-distance" id="total-distance"></div>
          </div>
          <div id="directions-steps"></div>
        </div>

        <div class="control-buttons">
          <button class="control-btn" id="reset-btn" title="Reset view">
            <span>‚Üª</span>
            <span>Reset</span>
          </button>
          <button class="control-btn" id="clear-btn" title="Clear route">
            <span>‚úï</span>
            <span>Clear</span>
          </button>
        </div>
      </div>

      <div class="map-footer">
        Multi-Floor Campus Navigation ‚Ä¢ Offline Ready<br>
        v3.1 with Complete Floor Routing
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
   // Register inline service worker
if ('serviceWorker' in navigator) {
  const swCode = `
    const CACHE_NAME = 'nile-campus-nav-v3';
    const urlsToCache = [
      'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
      'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'
    ];

    self.addEventListener('install', event => {
      event.waitUntil(
        caches.open(CACHE_NAME).then(cache => {
          return cache.addAll(urlsToCache);
        })
      );
      self.skipWaiting();
    });

    self.addEventListener('fetch', event => {
      event.respondWith(
        caches.match(event.request).then(response => {
          return response || fetch(event.request).then(fetchResponse => {
            return caches.open(CACHE_NAME).then(cache => {
              cache.put(event.request, fetchResponse.clone());
              return fetchResponse;
            });
          });
        }).catch(() => {
          return caches.match(event.request);
        })
      );
    });

    self.addEventListener('activate', event => {
      event.waitUntil(
        caches.keys().then(cacheNames => {
          return Promise.all(
            cacheNames.map(cacheName => {
              if (cacheName !== CACHE_NAME) {
                return caches.delete(cacheName);
              }
            })
          );
        })
      );
      self.clients.claim();
    });
  `;

  const blob = new Blob([swCode], { type: 'application/javascript' });
  const swUrl = URL.createObjectURL(blob);

  navigator.serviceWorker.register(swUrl).then(reg => {
    console.log('‚úÖ Service Worker registered:', reg);
  }).catch(err => {
    console.log('‚ùå Service Worker registration failed:', err);
  });
}

const CACHE_NAME = 'campus-map-v1';
const MAP_DATA_KEY = 'campus_map_data';

function clearAllPolylines() {
  // Remove from our tracking object
  Object.keys(currentPathPolylines).forEach(floor => {
    if (currentPathPolylines[floor]) {
      if (map.hasLayer(currentPathPolylines[floor])) {
        map.removeLayer(currentPathPolylines[floor]);
      }
      currentPathPolylines[floor] = null;
    }
  });
  currentPathPolylines = {};
  
  // Nuclear option: remove ALL polylines from the map
  map.eachLayer(function(layer) {
    if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
      map.removeLayer(layer);
    }
  });
}

function updateOnlineStatus() {
  const indicator = document.getElementById('offline-indicator');
  if (!navigator.onLine) {
    indicator.classList.add('show');
  } else {
    indicator.classList.remove('show');
  }
}

window.addEventListener('online', updateOnlineStatus);
window.addEventListener('offline', updateOnlineStatus);

const map = L.map('map', { crs: L.CRS.Simple, minZoom: -1, maxZoom: 3 });
const img_width = 1527;
const img_height = 1080;
const bounds = [[0, 0], [img_height, img_width]];

const groundFloorOverlay = L.imageOverlay('floor-1.png', bounds);
const upperFloorOverlay = L.imageOverlay('floor-1.png', bounds);

groundFloorOverlay.addTo(map);
map.fitBounds(bounds);

let currentFloor = 'ground';
let currentPathPolylines = {};
let startMarker = null;
let endMarker = null;
let routeMarkers = [];
let allMarkers = {};
let currentRoutePath = null;
let routeState = {
  active: false,
  waitingForFloorSwitch: false,
  selectedTransport: null,
  fullPath: null,
  currentFloorPath: null
};

const groundFloorRooms = {
  "Library": { x: 590, y: 892, category: "study", floor: "ground" },
  "Men Bathroom": { x: 468, y: 796, category: "facility", floor: "ground" },
  "Room 1": { x: 606, y: 806, category: "classroom", floor: "ground" },
  "IT Service Room": { x: 466, y: 722, category: "service", floor: "ground" },
  "68B": { x: 604, y: 728, category: "classroom", floor: "ground" },
  "Quick": { x: 318, y: 532, category: "food", floor: "ground" },
  "Elevators": { x: 464, y: 414, category: "transport", floor: "ground" },
  "Women Bathroom": { x: 460, y: 326, category: "facility", floor: "ground" },
  "Room 7": { x: 466, y: 258, category: "classroom", floor: "ground" },
  "Room 8": { x: 464, y: 181, category: "classroom", floor: "ground" },
  "IT Service Room 2": { x: 606, y: 177, category: "service", floor: "ground" },
  "Room 50": { x: 612, y: 252, category: "classroom", floor: "ground" },
  "Room 51": { x: 608, y: 332, category: "classroom", floor: "ground" },
  "Room 52A": { x: 716, y: 450, category: "classroom", floor: "ground" },
  "Room 52B": { x: 782, y: 450, category: "classroom", floor: "ground" },
  "Room 53": { x: 852, y: 450, category: "classroom", floor: "ground" },
  "Stairs": { x: 638, y: 612, category: "transport", floor: "ground" },
  "SU": { x: 702, y: 604, category: "office", floor: "ground" },
  "HUAC Lab": { x: 774, y: 604, category: "lab", floor: "ground" },
  "B43 Civil Lab": { x: 852, y: 604, category: "lab", floor: "ground" },
  "Men Bathroom 2": { x: 1140, y: 488, category: "facility", floor: "ground" },
  "SU Kitchen": { x: 1070, y: 133, category: "food", floor: "ground" },
  "Exit": { x: 1122, y: 898, category: "exit", floor: "ground" },
  "Logic Lab": { x: 1142, y: 796, category: "lab", floor: "ground" },
  "NUMC Music Club": { x: 990, y: 804, category: "club", floor: "ground" },
  "Physics Lab": { x: 993, y: 721, category: "lab", floor: "ground" },
  "Women Bathroom 2": { x: 1146, y: 542, category: "facility", floor: "ground" },
  "Elevators 2": { x: 1139, y: 601, category: "transport", floor: "ground" }
};

const upperFloorRooms = {
  "FLibrary": { x: 590, y: 892, category: "study", floor: "upper" },
  "FMen Bathroom": { x: 468, y: 796, category: "facility", floor: "upper" },
  "FRoom 1": { x: 606, y: 806, category: "classroom", floor: "upper" },
  "FIT Service Room": { x: 466, y: 722, category: "service", floor: "upper" },
  "F68B": { x: 604, y: 728, category: "classroom", floor: "upper" },
  "FQuick": { x: 318, y: 532, category: "food", floor: "upper" },
  "FElevators": { x: 464, y: 414, category: "transport", floor: "upper" },
  "FWomen Bathroom": { x: 460, y: 326, category: "facility", floor: "upper" },
  "FRoom 7": { x: 466, y: 258, category: "classroom", floor: "upper" },
  "FRoom 8": { x: 464, y: 181, category: "classroom", floor: "upper" },
  "FIT Service Room 2": { x: 606, y: 177, category: "service", floor: "upper" },
  "FRoom 50": { x: 612, y: 252, category: "classroom", floor: "upper" },
  "FRoom 51": { x: 608, y: 332, category: "classroom", floor: "upper" },
  "FRoom 52A": { x: 716, y: 450, category: "classroom", floor: "upper" },
  "FRoom 52B": { x: 782, y: 450, category: "classroom", floor: "upper" },
  "FRoom 53": { x: 852, y: 450, category: "classroom", floor: "upper" },
  "FStairs": { x: 638, y: 612, category: "transport", floor: "upper" },
  "FSU": { x: 702, y: 604, category: "office", floor: "upper" },
  "FHUAC Lab": { x: 774, y: 604, category: "lab", floor: "upper" },
  "FB43 Civil Lab": { x: 852, y: 604, category: "lab", floor: "upper" },
  "FMen Bathroom 2": { x: 1140, y: 488, category: "facility", floor: "upper" },
  "FSU Kitchen": { x: 1070, y: 133, category: "food", floor: "upper" },
  "FExit": { x: 1122, y: 898, category: "exit", floor: "upper" },
  "FLogic Lab": { x: 1142, y: 796, category: "lab", floor: "upper" },
  "FNUMC Music Club": { x: 990, y: 804, category: "club", floor: "upper" },
  "FPhysics Lab": { x: 993, y: 721, category: "lab", floor: "upper" },
  "FWomen Bathroom 2": { x: 1146, y: 542, category: "facility", floor: "upper" },
  "FElevators 2": { x: 1139, y: 601, category: "transport", floor: "upper" }
};

const rooms = { ...groundFloorRooms, ...upperFloorRooms };

const groundCorridorWaypoints = {};
const upperCorridorWaypoints = {};

for (let y = 170; y <= 820; y += 50) {
  groundCorridorWaypoints[`W_L${y}`] = { x: 540, y: y, floor: "ground" };
  upperCorridorWaypoints[`FW_L${y}`] = { x: 540, y: y, floor: "upper" };
}

for (let x = 280; x <= 1080; x += 50) {
  groundCorridorWaypoints[`W_H${x}`] = { x: x, y: 525, floor: "ground" };
  upperCorridorWaypoints[`FW_H${x}`] = { x: x, y: 525, floor: "upper" };
}

for (let y = 123; y <= 835; y += 50) {
  groundCorridorWaypoints[`W_R${y}`] = { x: 1080, y: y, floor: "ground" };
  upperCorridorWaypoints[`FW_R${y}`] = { x: 1080, y: y, floor: "upper" };
}

const corridorWaypoints = { ...groundCorridorWaypoints, ...upperCorridorWaypoints };

function cacheMapData() {
  const data = {
    rooms: rooms,
    corridorWaypoints: corridorWaypoints,
    timestamp: Date.now()
  };
  localStorage.setItem(MAP_DATA_KEY, JSON.stringify(data));
}
cacheMapData();

const allNodes = { ...rooms, ...corridorWaypoints };
const graph = {};
for (let node in allNodes) {
  graph[node] = [];
}

function addEdge(from, to) {
  const fromNode = allNodes[from];
  const toNode = allNodes[to];

  if (!fromNode || !toNode) return;

  const dx = toNode.x - fromNode.x;
  const dy = toNode.y - fromNode.y;
  let distance = Math.sqrt(dx * dx + dy * dy);

  if (fromNode.floor !== toNode.floor) {
    distance += 300;
  }

  graph[from].push({
    node: to,
    distance: distance,
    points: [[fromNode.x, fromNode.y], [toNode.x, toNode.y]],
    floorChange: fromNode.floor !== toNode.floor
  });

  graph[to].push({
    node: from,
    distance: distance,
    points: [[toNode.x, toNode.y], [fromNode.x, fromNode.y]],
    floorChange: fromNode.floor !== toNode.floor
  });
}

const leftWaypoints = Object.keys(groundCorridorWaypoints).filter(k => k.startsWith('W_L')).sort((a, b) => {
  return parseInt(a.substring(3)) - parseInt(b.substring(3));
});
for (let i = 0; i < leftWaypoints.length - 1; i++) {
  addEdge(leftWaypoints[i], leftWaypoints[i + 1]);
}

const horizWaypoints = Object.keys(groundCorridorWaypoints).filter(k => k.startsWith('W_H')).sort((a, b) => {
  return parseInt(a.substring(3)) - parseInt(b.substring(3));
});
for (let i = 0; i < horizWaypoints.length - 1; i++) {
  addEdge(horizWaypoints[i], horizWaypoints[i + 1]);
}

const rightWaypoints = Object.keys(groundCorridorWaypoints).filter(k => k.startsWith('W_R')).sort((a, b) => {
  return parseInt(a.substring(3)) - parseInt(b.substring(3));
});
for (let i = 0; i < rightWaypoints.length - 1; i++) {
  addEdge(rightWaypoints[i], rightWaypoints[i + 1]);
}

const upperLeftWaypoints = Object.keys(upperCorridorWaypoints).filter(k => k.startsWith('FW_L')).sort((a, b) => {
  return parseInt(a.substring(4)) - parseInt(b.substring(4));
});
for (let i = 0; i < upperLeftWaypoints.length - 1; i++) {
  addEdge(upperLeftWaypoints[i], upperLeftWaypoints[i + 1]);
}

const upperHorizWaypoints = Object.keys(upperCorridorWaypoints).filter(k => k.startsWith('FW_H')).sort((a, b) => {
  return parseInt(a.substring(4)) - parseInt(b.substring(4));
});
for (let i = 0; i < upperHorizWaypoints.length - 1; i++) {
  addEdge(upperHorizWaypoints[i], upperHorizWaypoints[i + 1]);
}

const upperRightWaypoints = Object.keys(upperCorridorWaypoints).filter(k => k.startsWith('FW_R')).sort((a, b) => {
  return parseInt(a.substring(4)) - parseInt(b.substring(4));
});
for (let i = 0; i < upperRightWaypoints.length - 1; i++) {
  addEdge(upperRightWaypoints[i], upperRightWaypoints[i + 1]);
}

addEdge('W_L520', 'W_H530');
addEdge('W_H1080', 'W_R523');
addEdge('FW_L520', 'FW_H530');
addEdge('FW_H1080', 'FW_R523');

addEdge('Elevators', 'FElevators');
addEdge('Elevators 2', 'FElevators 2');
addEdge('Stairs', 'FStairs');

Object.keys(groundFloorRooms).forEach(roomName => {
  const room = groundFloorRooms[roomName];
  let minDist = Infinity;
  let nearestWaypoint = null;

  Object.keys(groundCorridorWaypoints).forEach(waypointName => {
    const waypoint = groundCorridorWaypoints[waypointName];
    const dx = waypoint.x - room.x;
    const dy = waypoint.y - room.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < minDist) {
      minDist = dist;
      nearestWaypoint = waypointName;
    }
  });

  if (nearestWaypoint) {
    addEdge(roomName, nearestWaypoint);
  }
});

Object.keys(upperFloorRooms).forEach(roomName => {
  const room = upperFloorRooms[roomName];
  let minDist = Infinity;
  let nearestWaypoint = null;

  Object.keys(upperCorridorWaypoints).forEach(waypointName => {
    const waypoint = upperCorridorWaypoints[waypointName];
    const dx = waypoint.x - room.x;
    const dy = waypoint.y - room.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < minDist) {
      minDist = dist;
      nearestWaypoint = waypointName;
    }
  });

  if (nearestWaypoint) {
    addEdge(roomName, nearestWaypoint);
  }
});

function dijkstra(start, end, preferredTransport = null) {
  const distances = {};
  const previous = {};
  const pq = [];

  for (let node in graph) {
    distances[node] = Infinity;
    previous[node] = null;
  }

  distances[start] = 0;
  pq.push({ node: start, distance: 0 });

  while (pq.length > 0) {
    pq.sort((a, b) => a.distance - b.distance);
    const { node: current } = pq.shift();

    if (current === end) break;

    for (let neighbor of graph[current]) {
      // Filter transport method if specified
      if (preferredTransport && neighbor.floorChange) {
        const isElevator = current.includes('Elevator') || neighbor.node.includes('Elevator');
        const isStairs = current.includes('Stairs') || neighbor.node.includes('Stairs');
        
        if (preferredTransport === 'elevator' && !isElevator) continue;
        if (preferredTransport === 'stairs' && !isStairs) continue;
      }

      const alt = distances[current] + neighbor.distance;
      if (alt < distances[neighbor.node]) {
        distances[neighbor.node] = alt;
        previous[neighbor.node] = {
          node: current,
          points: neighbor.points,
          floorChange: neighbor.floorChange
        };
        pq.push({ node: neighbor.node, distance: alt });
      }
    }
  }

  const path = [];
  let current = end;
  while (previous[current]) {
    path.unshift({
      node: current,
      points: previous[current].points,
      floorChange: previous[current].floorChange
    });
    current = previous[current].node;
  }
  if (path.length > 0) path.unshift({ node: start, points: [], floorChange: false });

  return { path, distance: distances[end] };
}

function getPolylinePointsByFloor(pathNodes, targetFloor = null) {
  const pointsByFloor = {
    ground: [],
    upper: []
  };

  for (let i = 0; i < pathNodes.length - 1; i++) {
    const currentNode = allNodes[pathNodes[i].node];
    const nextNode = allNodes[pathNodes[i + 1].node];

    // Skip floor transitions
    if (pathNodes[i + 1].floorChange) continue;

    // Only add if BOTH nodes are on the same floor
    if (currentNode.floor === nextNode.floor) {
      const floor = currentNode.floor;
      const segment = pathNodes[i + 1].points;
      
      // If targetFloor is specified, only add for that floor
      if (targetFloor === null || floor === targetFloor) {
        pointsByFloor[floor].push(...segment);
      }
    }
  }

  return pointsByFloor;
}

function generateDirections(pathNodes) {
  const directions = [];
  let currentDirection = null;
  let stepDistance = 0;

  for (let i = 0; i < pathNodes.length - 1; i++) {
    const current = allNodes[pathNodes[i].node];
    const next = allNodes[pathNodes[i + 1].node];

    const dx = next.x - current.x;
    const dy = next.y - current.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (pathNodes[i + 1].floorChange) {
      if (stepDistance > 0) {
        directions.push({
          instruction: `Continue straight`,
          distance: (stepDistance * 0.3).toFixed(0),
          type: 'continue'
        });
      }

      const transportType = pathNodes[i].node.includes('Elevator') ? 'üõó elevator' : 'üö∂ stairs';
      directions.push({
        instruction: `Take the ${transportType} to ${next.floor === 'upper' ? 'upper floor' : 'ground floor'}`,
        distance: '0',
        type: 'floor-change',
        floor: next.floor
      });
      stepDistance = 0;
      currentDirection = null;
      continue;
    }

    let direction = null;
    if (Math.abs(dx) > Math.abs(dy)) {
      direction = dx > 0 ? 'right' : 'left';
    } else {
      direction = dy > 0 ? 'down' : 'up';
    }

    if (direction !== currentDirection && currentDirection !== null) {
      directions.push({
        instruction: getTurnInstruction(currentDirection, direction),
        distance: (stepDistance * 0.3).toFixed(0),
        type: 'turn'
      });
      stepDistance = distance;
    } else {
      stepDistance += distance;
    }

    currentDirection = direction;
  }

  if (stepDistance > 0) {
    directions.push({
      instruction: `Continue straight`,
      distance: (stepDistance * 0.3).toFixed(0),
      type: 'continue'
    });
  }

  return directions;
}

function getTurnInstruction(from, to) {
  const turns = {
    'right-up': 'Turn left',
    'right-down': 'Turn right',
    'left-up': 'Turn right',
    'left-down': 'Turn left',
    'up-right': 'Turn right',
    'up-left': 'Turn left',
    'down-right': 'Turn left',
    'down-left': 'Turn right'
  };
  return turns[`${from}-${to}`] || 'Continue';
}

function displayDirections(directions, startRoom, endRoom) {
  const panel = document.getElementById('directions-panel');
  const stepsContainer = document.getElementById('directions-steps');
  stepsContainer.innerHTML = '';

  const startFloor = rooms[startRoom].floor === 'upper' ? 'Upper Floor' : 'Ground Floor';
  const startStep = document.createElement('div');
  startStep.className = 'direction-step';
  startStep.innerHTML = `
    <div class="step-number">üö©</div>
    <div class="step-content">
      <div class="step-instruction">Start at ${startRoom}</div>
      <div class="step-detail">${startFloor} - Begin your journey</div>
    </div>
  `;
  stepsContainer.appendChild(startStep);

  directions.forEach((dir, index) => {
    const step = document.createElement('div');
    step.className = 'direction-step';

    let icon = index + 1;
    let detail = `~${dir.distance}m ahead`;

    if (dir.type === 'floor-change') {
      icon = dir.instruction.includes('elevator') ? 'üõó' : 'üö∂';
      detail = dir.floor === 'upper' ? 'Go to Upper Floor' : 'Go to Ground Floor';
    }

    step.innerHTML = `
      <div class="step-number">${icon}</div>
      <div class="step-content">
        <div class="step-instruction">${dir.instruction}</div>
        <div class="step-detail">${detail}</div>
      </div>
    `;
    stepsContainer.appendChild(step);
  });

  const endFloor = rooms[endRoom].floor === 'upper' ? 'Upper Floor' : 'Ground Floor';
  const endStep = document.createElement('div');
  endStep.className = 'direction-step';
  endStep.innerHTML = `
    <div class="step-number">üìå</div>
    <div class="step-content">
      <div class="step-instruction">Arrive at ${endRoom}</div>
      <div class="step-detail">${endFloor} - You've reached your destination</div>
    </div>
  `;
  stepsContainer.appendChild(endStep);

  panel.classList.add('active');
}

const roomNames = Object.keys(rooms);

const categoryIcons = {
  study: 'üìö',
  facility: 'üöª',
  classroom: 'üéì',
  service: 'üîß',
  food: 'üçΩÔ∏è',
  transport: 'üö™',
  lab: 'üî¨',
  office: 'üè¢',
  club: 'üéµ',
  exit: 'üö™'
};

function createCategoryIcon(category, isStart = false, isEnd = false) {
  const colors = {
    study: '#3b82f6',
    facility: '#8b5cf6',
    classroom: '#10b981',
    service: '#f59e0b',
    food: '#ef4444',
    transport: '#6366f1',
    lab: '#06b6d4',
    office: '#ec4899',
    club: '#a855f7',
    exit: '#64748b'
  };

  const color = colors[category] || '#6366f1';
  const icon = categoryIcons[category] || 'üìç';

  let className = 'custom-location-marker';
  if (isStart) className = 'start-marker';
  if (isEnd) className = 'end-marker';

  return L.divIcon({
    className: className,
    html: `<div class="marker-pin" style="background: ${color};">
             <span class="marker-icon">${icon}</span>
           </div>
           <div class="marker-pulse" style="background: ${color};"></div>`,
    iconSize: [40, 40],
    iconAnchor: [20, 40],
    popupAnchor: [0, -40]
  });
}

function setupAutocomplete(inputElement, boxElement) {
  inputElement.addEventListener('input', function () {
    const query = this.value.toLowerCase();
    boxElement.innerHTML = '';

    if (query.length < 1) {
      boxElement.style.display = 'none';
      return;
    }

    const matches = roomNames.filter(name =>
      name.toLowerCase().includes(query)
    ).slice(0, 8);

    if (matches.length > 0) {
      matches.forEach(name => {
        const room = rooms[name];
        const icon = categoryIcons[room.category] || 'üìç';
        const floorLabel = room.floor === 'upper' ? 'F1' : 'F0';
        const item = document.createElement('div');
        item.className = 'autocomplete-item';
        item.innerHTML = `
          <span class="autocomplete-icon">${icon}</span>
          <span>${name}</span>
          <span class="room-floor-badge">${floorLabel}</span>
        `;
        item.addEventListener('click', function () {
          inputElement.value = name;
          boxElement.style.display = 'none';
        });
        boxElement.appendChild(item);
      });
      boxElement.style.display = 'block';
    } else {
      boxElement.style.display = 'none';
    }
  });

  document.addEventListener('click', function (e) {
    if (!inputElement.contains(e.target)) {
      boxElement.style.display = 'none';
    }
  });
}

const startInput = document.getElementById('start-input');
const endInput = document.getElementById('end-input');
const startBox = document.getElementById('start-box');
const endBox = document.getElementById('end-box');

setupAutocomplete(startInput, startBox);
setupAutocomplete(endInput, endBox);

function createMarkersForFloor(floor) {
  const floorRooms = floor === 'ground' ? groundFloorRooms : upperFloorRooms;
  const markers = [];

  Object.keys(floorRooms).forEach(roomName => {
    const room = floorRooms[roomName];
    const marker = L.marker(
      [room.y, room.x],
      { icon: createCategoryIcon(room.category) }
    );

    marker.bindPopup(`
      <div style="padding: 8px;">
        <h3 style="margin: 0 0 8px 0; font-size: 15px; font-weight: 600; color: #fff;">
          ${categoryIcons[room.category]} ${roomName}
        </h3>
        <p style="margin: 0; font-size: 12px; color: #94a3b8; text-transform: capitalize;">
          ${room.category} ‚Ä¢ ${room.floor === 'upper' ? 'Upper Floor' : 'Ground Floor'}
        </p>
        <div style="margin-top: 12px; display: flex; gap: 8px;">
          <button onclick="setAsStart('${roomName}')" 
            style="flex: 1; padding: 6px; background: #10b981; border: none; border-radius: 6px; color: white; font-size: 11px; cursor: pointer; font-weight: 600;">
            Start Here
          </button>
          <button onclick="setAsEnd('${roomName}')" 
            style="flex: 1; padding: 6px; background: #6366f1; border: none; border-radius: 6px; color: white; font-size: 11px; cursor: pointer; font-weight: 600;">
            Go Here
          </button>
        </div>
      </div>
    `);

    markers.push(marker);
  });

  return markers;
}

allMarkers['ground'] = createMarkersForFloor('ground');
allMarkers['upper'] = createMarkersForFloor('upper');

allMarkers['ground'].forEach(marker => marker.addTo(map));

document.querySelectorAll('.floor-btn').forEach(btn => {
  btn.addEventListener('click', function () {
    const targetFloor = this.dataset.floor;

    if (targetFloor === currentFloor) return;

    document.querySelectorAll('.floor-btn').forEach(b => b.classList.remove('active'));
    this.classList.add('active');

    // Switch floor overlay
    if (targetFloor === 'ground') {
      map.removeLayer(upperFloorOverlay);
      groundFloorOverlay.addTo(map);
    } else {
      map.removeLayer(groundFloorOverlay);
      upperFloorOverlay.addTo(map);
    }

    // Switch markers
    allMarkers[currentFloor].forEach(marker => map.removeLayer(marker));
    allMarkers[targetFloor].forEach(marker => marker.addTo(map));

    // CRITICAL: Remove ALL polylines from map first
    map.eachLayer(function(layer) {
      if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
        map.removeLayer(layer);
      }
    });

    // Only add back the polyline for the target floor if it exists
    if (currentPathPolylines[targetFloor]) {
      currentPathPolylines[targetFloor].addTo(map);
    }

    // Handle markers
    if (startMarker) map.removeLayer(startMarker);
    if (endMarker) map.removeLayer(endMarker);
    routeMarkers.forEach(marker => map.removeLayer(marker));
    routeMarkers = [];

    if (currentRoutePath) {
      const startRoom = currentRoutePath.start;
      const endRoom = currentRoutePath.end;
      const startPos = rooms[startRoom];
      const endPos = rooms[endRoom];

      if (startPos.floor === targetFloor) {
        startMarker = L.marker(
          [startPos.y, startPos.x],
          { icon: createCategoryIcon(startPos.category, true, false) }
        ).addTo(map);
        startMarker.bindPopup(`<strong>üö© Start:</strong> ${startRoom}`);
      }

      if (endPos.floor === targetFloor) {
        endMarker = L.marker(
          [endPos.y, endPos.x],
          { icon: createCategoryIcon(endPos.category, false, true) }
        ).addTo(map);
        endMarker.bindPopup(`<strong>üìå Destination:</strong> ${endRoom}`);
      }
    }

    currentFloor = targetFloor;

    showNotification(`üè¢ Switched to ${targetFloor === 'ground' ? 'Ground' : 'Upper'} Floor`, 'info');
  });
});

window.setAsStart = function (roomName) {
  startInput.value = roomName;
  map.closePopup();
};

window.setAsEnd = function (roomName) {
  endInput.value = roomName;
  map.closePopup();
};

function showTransportChoice(startRoom, endRoom) {
  const modal = document.createElement('div');
  modal.id = 'transport-modal';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10002;
    animation: fadeIn 0.3s ease;
  `;

  modal.innerHTML = `
    <div style="background: var(--bg-secondary); padding: 32px; border-radius: 16px; max-width: 450px; width: 90%; box-shadow: 0 12px 48px rgba(0, 0, 0, 0.5); border: 1px solid var(--border-color);">
      <h2 style="margin: 0 0 12px 0; font-size: 22px; font-weight: 700; color: var(--text-primary);">
        üö∂ Choose Your Transport
      </h2>
      <p style="margin: 0 0 24px 0; font-size: 14px; color: var(--text-secondary); line-height: 1.6;">
        Your route requires changing floors. How would you like to travel?
      </p>
      <div style="display: flex; flex-direction: column; gap: 12px;">
        <button id="choose-elevator" style="padding: 16px 24px; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px; transition: transform 0.2s ease;">
          <span style="font-size: 24px;">üõó</span>
          <span>Take Elevator</span>
        </button>
        <button id="choose-stairs" style="padding: 16px 24px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; border-radius: 12px; color: white; font-size: 15px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px; transition: transform 0.2s ease;">
          <span style="font-size: 24px;">üö∂</span>
          <span>Take Stairs</span>
        </button>
        <button id="cancel-choice" style="padding: 12px 24px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 10px; color: #ef4444; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
          Cancel
        </button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  document.getElementById('choose-elevator').addEventListener('click', function() {
    this.style.transform = 'scale(0.95)';
    setTimeout(() => {
      modal.remove();
      calculateRouteWithTransport(startRoom, endRoom, 'elevator');
    }, 150);
  });

  document.getElementById('choose-stairs').addEventListener('click', function() {
    this.style.transform = 'scale(0.95)';
    setTimeout(() => {
      modal.remove();
      calculateRouteWithTransport(startRoom, endRoom, 'stairs');
    }, 150);
  });

  document.getElementById('cancel-choice').addEventListener('click', function() {
    modal.remove();
  });

  modal.addEventListener('click', function(e) {
    if (e.target === modal) {
      modal.remove();
    }
  });
}

function calculateRouteWithTransport(startRoom, endRoom, transport) {
  const { path, distance } = dijkstra(startRoom, endRoom, transport);

  if (path.length === 0 || distance === Infinity) {
    showNotification('‚ùå No route found with selected transport', 'error');
    return;
  }

  // NUCLEAR CLEAR - remove everything
  clearAllPolylines();

  if (startMarker) {
    map.removeLayer(startMarker);
    startMarker = null;
  }
  if (endMarker) {
    map.removeLayer(endMarker);
    endMarker = null;
  }
  routeMarkers.forEach(marker => map.removeLayer(marker));
  routeMarkers = [];

  routeState.active = true;
  routeState.fullPath = path;
  routeState.selectedTransport = transport;

  currentRoutePath = { start: startRoom, end: endRoom, path: path };

  const startFloor = rooms[startRoom].floor;
  
  // Make sure we're on the starting floor
  if (currentFloor !== startFloor) {
    document.querySelector(`[data-floor="${startFloor}"]`).click();
    // Wait for floor switch to complete
    setTimeout(() => {
      calculateRouteWithTransport(startRoom, endRoom, transport);
    }, 100);
    return;
  }
  
  // Find floor change point
  let floorChangeIndex = -1;
  for (let i = 0; i < path.length; i++) {
    if (path[i].floorChange) {
      floorChangeIndex = i;
      break;
    }
  }

  // Build points array ONLY for current floor, ONLY until floor change
  const currentFloorPoints = [];
  
  for (let i = 0; i < path.length - 1; i++) {
    const currentNode = allNodes[path[i].node];
    const nextNode = allNodes[path[i + 1].node];

    // STOP at floor change
    if (path[i + 1].floorChange) {
      break;
    }

    // ONLY add if BOTH nodes are on starting floor
    if (currentNode.floor === startFloor && nextNode.floor === startFloor) {
      const segment = path[i + 1].points;
      currentFloorPoints.push(...segment);
    }
  }

  console.log(`Drawing route on ${startFloor} with ${currentFloorPoints.length} points`);

  // Draw ONLY on current floor
  if (currentFloorPoints.length > 0) {
    const polyline = L.polyline(
      currentFloorPoints.map(p => [p[1], p[0]]),
      {
        color: '#10b981',
        weight: 6,
        opacity: 0.8,
        lineJoin: 'round',
        lineCap: 'round',
        dashArray: '0, 10',
        className: 'animated-route'
      }
    );

    // Store it
    currentPathPolylines[startFloor] = polyline;
    
    // Add ONLY to map if we're on that floor
    if (currentFloor === startFloor) {
      polyline.addTo(map);
      console.log(`Polyline added to ${startFloor} floor`);
    }

    let offset = 0;
    const animationInterval = setInterval(() => {
      offset += 1;
      if (polyline && map.hasLayer(polyline)) {
        polyline.setStyle({ dashOffset: offset + 'px' });
      } else {
        clearInterval(animationInterval);
      }
    }, 100);

    map.fitBounds(polyline.getBounds(), { padding: [50, 50] });
  }

  const startPos = rooms[startRoom];
  startMarker = L.marker(
    [startPos.y, startPos.x],
    { icon: createCategoryIcon(startPos.category, true, false) }
  ).addTo(map);
  startMarker.bindPopup(`<strong>üö© Start:</strong> ${startRoom}`);

  if (floorChangeIndex !== -1) {
    routeState.waitingForFloorSwitch = true;
    
    const transportNode = allNodes[path[floorChangeIndex].node];
    if (transportNode.floor === startFloor) {
      const transportMarker = L.marker(
        [transportNode.y, transportNode.x],
        { icon: createCategoryIcon('transport', false, false) }
      ).addTo(map);
      
      routeMarkers.push(transportMarker);
    }

    showContinueButton();
  } else {
    const endPos = rooms[endRoom];
    endMarker = L.marker(
      [endPos.y, endPos.x],
      { icon: createCategoryIcon(endPos.category, false, true) }
    ).addTo(map);
    endMarker.bindPopup(`<strong>üìå Destination:</strong> ${endRoom}`);
  }

  const distanceMeters = (distance * 0.3).toFixed(0);
  const timeMinutes = Math.ceil(distanceMeters / 80);

  const routeInfo = document.getElementById('route-info');
  const floorChangeCount = path.filter(p => p.floorChange).length;
  const floorInfo = floorChangeCount > 0 ? ` ‚Ä¢ ${floorChangeCount} floor change${floorChangeCount > 1 ? 's' : ''}` : '';

  routeInfo.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
      <div style="font-weight: 700; color: #10b981; font-size: 15px;">Route Found!</div>
      <div style="font-size: 12px; color: #64748b;">${path.length - 1} segments${floorInfo}</div>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;">
      <div style="background: rgba(16, 185, 129, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.3);">
        <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Distance</div>
        <div style="font-size: 18px; font-weight: 700; color: #10b981;">~${distanceMeters}m</div>
      </div>
      <div style="background: rgba(99, 102, 241, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3);">
        <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Est. Time</div>
        <div style="font-size: 18px; font-weight: 700; color: #6366f1;">~${timeMinutes} min</div>
      </div>
    </div>
  `;
  routeInfo.classList.add('active');

  const pathSegment = floorChangeIndex !== -1 ? path.slice(0, floorChangeIndex + 1) : path;
  const directions = generateDirections(pathSegment);
  displayDirections(directions, startRoom, floorChangeIndex !== -1 ? path[floorChangeIndex].node : endRoom);

  document.getElementById('total-distance').textContent = `~${distanceMeters}m ‚Ä¢ ${timeMinutes} min walk`;

  showNotification(`‚úÖ Route calculated via ${transport}!`, 'success');
}

function showContinueButton() {
  let continueBtn = document.getElementById('continue-route-btn');
  
  if (!continueBtn) {
    continueBtn = document.createElement('button');
    continueBtn.id = 'continue-route-btn';
    continueBtn.innerHTML = `
      <span>‚úÖ</span>
      <span>I've Arrived - Continue Route</span>
    `;
    continueBtn.style.cssText = `
      padding: 16px 24px;
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      border: none;
      border-radius: 12px;
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
      margin-top: 12px;
      animation: pulse 2s infinite;
    `;

    continueBtn.addEventListener('click', continueToNextFloor);
    
    const routeBtn = document.getElementById('route-btn');
    routeBtn.parentNode.insertBefore(continueBtn, routeBtn.nextSibling);
  }

  continueBtn.style.display = 'flex';
}

function hideContinueButton() {
  const continueBtn = document.getElementById('continue-route-btn');
  if (continueBtn) {
    continueBtn.style.display = 'none';
  }
}

function continueToNextFloor() {
  if (!routeState.waitingForFloorSwitch || !routeState.fullPath) {
    return;
  }

  const path = routeState.fullPath;
  let floorChangeIndex = -1;

  for (let i = 0; i < path.length; i++) {
    if (path[i].floorChange) {
      floorChangeIndex = i;
      break;
    }
  }

  if (floorChangeIndex === -1) {
    return;
  }

  const targetFloor = allNodes[path[floorChangeIndex + 1].node].floor;

  // Switch to the target floor
  document.querySelector(`[data-floor="${targetFloor}"]`).click();

  setTimeout(() => {
    // Clear everything first
    clearAllPolylines();
    
    // Build points ONLY for target floor AFTER floor change
    const targetFloorPoints = [];
    
    for (let i = floorChangeIndex; i < path.length - 1; i++) {
      const currentNode = allNodes[path[i].node];
      const nextNode = allNodes[path[i + 1].node];

      // ONLY add if BOTH nodes are on target floor
      if (currentNode.floor === targetFloor && nextNode.floor === targetFloor) {
        const segment = path[i + 1].points;
        targetFloorPoints.push(...segment);
      }
    }

    console.log(`Drawing continuation on ${targetFloor} with ${targetFloorPoints.length} points`);

    if (targetFloorPoints.length > 0) {
      const polyline = L.polyline(
        targetFloorPoints.map(p => [p[1], p[0]]),
        {
          color: '#10b981',
          weight: 6,
          opacity: 0.8,
          lineJoin: 'round',
          lineCap: 'round',
          dashArray: '0, 10',
          className: 'animated-route'
        }
      );

      currentPathPolylines[targetFloor] = polyline;
      polyline.addTo(map);

      let offset = 0;
      const animationInterval = setInterval(() => {
        offset += 1;
        if (polyline && map.hasLayer(polyline)) {
          polyline.setStyle({ dashOffset: offset + 'px' });
        } else {
          clearInterval(animationInterval);
        }
      }, 100);

      map.fitBounds(polyline.getBounds(), { padding: [50, 50] });
    }

    const endRoom = currentRoutePath.end;
    const endPos = rooms[endRoom];
    
    if (endPos.floor === targetFloor) {
      endMarker = L.marker(
        [endPos.y, endPos.x],
        { icon: createCategoryIcon(endPos.category, false, true) }
      ).addTo(map);
      endMarker.bindPopup(`<strong>üìå Destination:</strong> ${endRoom}`);
    }

    routeMarkers.forEach(marker => map.removeLayer(marker));
    routeMarkers = [];

    routeState.waitingForFloorSwitch = false;
    hideContinueButton();

    showNotification(`üéØ Route continues on ${targetFloor === 'ground' ? 'Ground' : 'Upper'} Floor`, 'success');

    const pathAfterFloorChange = path.slice(floorChangeIndex + 1);
    const directions = generateDirections(pathAfterFloorChange);
    displayDirections(directions, path[floorChangeIndex + 1].node, endRoom);
  }, 500);
}

document.getElementById('route-btn').addEventListener('click', function () {
  const startRoom = startInput.value.trim();
  const endRoom = endInput.value.trim();

  if (!rooms[startRoom]) {
    showNotification('‚ùå Start location not found', 'error');
    return;
  }

  if (!rooms[endRoom]) {
    showNotification('‚ùå Destination not found', 'error');
    return;
  }

  if (startRoom === endRoom) {
    showNotification('‚ö†Ô∏è Start and destination cannot be the same', 'error');
    return;
  }

  const startFloor = rooms[startRoom].floor;
  const endFloor = rooms[endRoom].floor;

  if (startFloor !== endFloor) {
    showTransportChoice(startRoom, endRoom);
  } else {
    const { path, distance } = dijkstra(startRoom, endRoom);

    if (path.length === 0 || distance === Infinity) {
      showNotification('‚ùå No route found', 'error');
      return;
    }

    Object.values(currentPathPolylines).forEach(polyline => {
      if (polyline) map.removeLayer(polyline);
    });
    currentPathPolylines = {};

    if (startMarker) map.removeLayer(startMarker);
    if (endMarker) map.removeLayer(endMarker);

    currentRoutePath = { start: startRoom, end: endRoom, path: path };

    if (startFloor !== currentFloor) {
      document.querySelector(`[data-floor="${startFloor}"]`).click();
    }

    const pointsByFloor = getPolylinePointsByFloor(path);

    if (pointsByFloor[startFloor].length > 0) {
      const polyline = L.polyline(
        pointsByFloor[startFloor].map(p => [p[1], p[0]]),
        {
          color: '#10b981',
          weight: 6,
          opacity: 0.8,
          lineJoin: 'round',
          lineCap: 'round',
          dashArray: '0, 10',
          className: 'animated-route'
        }
      );

      currentPathPolylines[startFloor] = polyline;
      polyline.addTo(map);

      let offset = 0;
      setInterval(() => {
        offset += 1;
        if (polyline) {
          polyline.setStyle({ dashOffset: offset + 'px' });
        }
      }, 100);
    }

    const startPos = rooms[startRoom];
    const endPos = rooms[endRoom];

    startMarker = L.marker(
      [startPos.y, startPos.x],
      { icon: createCategoryIcon(startPos.category, true, false) }
    ).addTo(map);
    startMarker.bindPopup(`<strong>üö© Start:</strong> ${startRoom}`);

    endMarker = L.marker(
      [endPos.y, endPos.x],
      { icon: createCategoryIcon(endPos.category, false, true) }
    ).addTo(map);
    endMarker.bindPopup(`<strong>üìå Destination:</strong> ${endRoom}`);

    if (currentPathPolylines[startFloor]) {
      map.fitBounds(currentPathPolylines[startFloor].getBounds(), { padding: [50, 50] });
    }

    const distanceMeters = (distance * 0.3).toFixed(0);
    const timeMinutes = Math.ceil(distanceMeters / 80);

    const routeInfo = document.getElementById('route-info');

    routeInfo.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <div style="font-weight: 700; color: #10b981; font-size: 15px;">Route Found!</div>
        <div style="font-size: 12px; color: #64748b;">${path.length - 1} segments</div>
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;">
        <div style="background: rgba(16, 185, 129, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(16, 185, 129, 0.3);">
          <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Distance</div>
          <div style="font-size: 18px; font-weight: 700; color: #10b981;">~${distanceMeters}m</div>
        </div>
        <div style="background: rgba(99, 102, 241, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(99, 102, 241, 0.3);">
          <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">Est. Time</div>
          <div style="font-size: 18px; font-weight: 700; color: #6366f1;">~${timeMinutes} min</div>
        </div>
      </div>
    `;
    routeInfo.classList.add('active');

    const directions = generateDirections(path);
    displayDirections(directions, startRoom, endRoom);

    document.getElementById('total-distance').textContent = `~${distanceMeters}m ‚Ä¢ ${timeMinutes} min walk`;

    showNotification('‚úÖ Route calculated!', 'success');
  }
});

document.getElementById('clear-btn').addEventListener('click', function () {
  Object.values(currentPathPolylines).forEach(polyline => {
    if (polyline) map.removeLayer(polyline);
  });
  currentPathPolylines = {};
  currentRoutePath = null;

  if (startMarker) {
    map.removeLayer(startMarker);
    startMarker = null;
  }
  if (endMarker) {
    map.removeLayer(endMarker);
    endMarker = null;
  }

  routeMarkers.forEach(marker => map.removeLayer(marker));
  routeMarkers = [];

  routeState = {
    active: false,
    waitingForFloorSwitch: false,
    selectedTransport: null,
    fullPath: null,
    currentFloorPath: null
  };

  hideContinueButton();

  startInput.value = '';
  endInput.value = '';

  document.getElementById('directions-panel').classList.remove('active');
  document.getElementById('route-info').classList.remove('active');

  showNotification('üóëÔ∏è Route cleared', 'info');
});

document.getElementById('reset-btn').addEventListener('click', function () {
  map.fitBounds(bounds);
  showNotification('‚Üª View reset', 'info');
});

function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = 'notification';
  notification.textContent = message;

  const colors = {
    success: '#10b981',
    error: '#ef4444',
    info: '#6366f1'
  };

  notification.style.cssText = `
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: ${colors[type]};
    color: white;
    padding: 12px 24px;
    border-radius: 10px;
    font-size: 14px;
    font-weight: 600;
    z-index: 10001;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    animation: slideDown 0.3s ease;
  `;

  document.body.appendChild(notification);

  setTimeout(() => {
    notification.style.animation = 'fadeOut 0.3s ease';
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

document.addEventListener('keydown', (e) => {
  if (e.ctrlKey || e.metaKey) {
    switch (e.key) {
      case 'k':
        e.preventDefault();
        startInput.focus();
        break;
      case 'Enter':
        e.preventDefault();
        document.getElementById('route-btn').click();
        break;
      case 'Backspace':
        e.preventDefault();
        document.getElementById('clear-btn').click();
        break;
    }
  }
});

console.log('üó∫Ô∏è Nile University Multi-Floor Campus Navigator v3.1 - Ready!');

function initThemeToggle() {
  const body = document.body;
  const themeToggle = document.getElementById('themeToggle');

  if (!themeToggle) return;

  const sunIcon = themeToggle.querySelector('.sun-icon');
  const moonIcon = themeToggle.querySelector('.moon-icon');

  const currentTheme = localStorage.getItem('theme') || 'dark';
  if (currentTheme === 'light') {
    body.classList.add('light-mode');
    sunIcon.style.display = 'none';
    moonIcon.style.display = 'block';
  } else {
    sunIcon.style.display = 'block';
    moonIcon.style.display = 'none';
  }

  themeToggle.addEventListener('click', function() {
    body.classList.toggle('light-mode');
    const isLight = body.classList.contains('light-mode');

    sunIcon.style.display = isLight ? 'none' : 'block';
    moonIcon.style.display = isLight ? 'block' : 'none';

    localStorage.setItem('theme', isLight ? 'light' : 'dark');

    showNotification(isLight ? '‚òÄÔ∏è Light mode enabled' : 'üåô Dark mode enabled', 'info');
  });
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initThemeToggle);
} else {
  initThemeToggle();
}
</script>
</body>

</html>
